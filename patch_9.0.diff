diff -Nur src.orig/sys/amd64/conf/GENERIC src/sys/amd64/conf/GENERIC
--- src.orig/sys/amd64/conf/GENERIC	2012-03-08 09:42:49.000000000 +0800
+++ src/sys/amd64/conf/GENERIC	2012-03-08 09:43:43.000000000 +0800
@@ -163,7 +163,7 @@
 
 # PCCARD (PCMCIA) support
 # PCMCIA and cardbus bridge support
-device		cbb		# cardbus (yenta) bridge
+# device		cbb		# cardbus (yenta) bridge
 device		pccard		# PC Card (16-bit) bus
 device		cardbus		# CardBus (32-bit) bus
 
diff -Nur src.orig/sys/conf/files src/sys/conf/files
--- src.orig/sys/conf/files	2012-03-08 09:40:46.000000000 +0800
+++ src/sys/conf/files	2012-03-08 07:07:33.000000000 +0800
@@ -1412,6 +1412,7 @@
 dev/mfi/mfi_disk.c		optional mfi
 dev/mfi/mfi_linux.c		optional mfi compat_linux
 dev/mfi/mfi_cam.c		optional mfip scbus
+dev/mfi/mfi_syspd.c		optional mfi
 dev/mii/acphy.c			optional miibus | acphy
 dev/mii/amphy.c			optional miibus | amphy
 dev/mii/atphy.c			optional miibus | atphy
diff -Nur src.orig/sys/dev/mfi/Makefile src/sys/dev/mfi/Makefile
--- src.orig/sys/dev/mfi/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ src/sys/dev/mfi/Makefile	2010-02-18 14:51:16.000000000 +0800
@@ -0,0 +1,5 @@
+.PATH: ${.CURDIR}/../../dev/mfi
+
+SRCS=mfi.c mfi_pci.c mfi_disk.c mfi_syspd.c mfi_cam.c mfi_debug.c device_if.h bus_if.h pci_if.h opt_mfi.h opt_cam.h 
+KMOD=mfi
+.include <bsd.kmod.mk>
diff -Nur src.orig/sys/dev/mfi/mfi.c src/sys/dev/mfi/mfi.c
--- src.orig/sys/dev/mfi/mfi.c	2012-01-03 11:26:42.000000000 +0800
+++ src/sys/dev/mfi/mfi.c	2012-03-10 16:23:16.000000000 +0800
@@ -1,57 +1,38 @@
 /*-
- * Copyright (c) 2006 IronPort Systems
- * All rights reserved.
- *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
  *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-/*-
- * Copyright (c) 2007 LSI Corp.
- * Copyright (c) 2007 Rajesh Prabhakaran.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
+ *            Copyright 1994-2009 The FreeBSD Project.
+ *            All rights reserved.   
+ *                 
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
+ *    THIS SOFTWARE IS PROVIDED BY THE FREEBSD PROJECT``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FREEBSD PROJECT OR 
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY,OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY THEORY 
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * The views and conclusions contained in the software and documentation 
+ * are those of the authors and should not be interpreted as representing 
+ * official policies,either expressed or implied, of the FreeBSD Project.	
  */
 
+
+
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: release/9.0.0/sys/dev/mfi/mfi.c 227534 2011-11-15 17:42:00Z delphij $");
+__FBSDID("$FreeBSD: src/sys/dev/mfi/mfi.c,v 1.37 2008/04/16 16:47:13 kris Exp $");
 
 #include "opt_mfi.h"
 
@@ -86,28 +67,33 @@
 static int	mfi_get_controller_info(struct mfi_softc *);
 static int	mfi_get_log_state(struct mfi_softc *,
 		    struct mfi_evt_log_state **);
-static int	mfi_parse_entries(struct mfi_softc *, int, int);
+static int	mfi_get_entry(struct mfi_softc *, int);
 static int	mfi_dcmd_command(struct mfi_softc *, struct mfi_command **,
 		    uint32_t, void **, size_t);
 static void	mfi_data_cb(void *, bus_dma_segment_t *, int, int);
 static void	mfi_startup(void *arg);
 static void	mfi_intr(void *arg);
 static void	mfi_ldprobe(struct mfi_softc *sc);
+static void	mfi_syspdprobe(struct mfi_softc *sc);
 static int	mfi_aen_register(struct mfi_softc *sc, int seq, int locale);
 static void	mfi_aen_complete(struct mfi_command *);
 static int	mfi_aen_setup(struct mfi_softc *, uint32_t);
 static int	mfi_add_ld(struct mfi_softc *sc, int);
 static void	mfi_add_ld_complete(struct mfi_command *);
+static int	mfi_add_sys_pd(struct mfi_softc *sc, int);
+static void	mfi_add_sys_pd_complete(struct mfi_command *);
 static struct mfi_command * mfi_bio_command(struct mfi_softc *);
 static void	mfi_bio_complete(struct mfi_command *);
+static struct mfi_command * mfi_build_ldio(struct mfi_softc *,struct bio*);
+static struct mfi_command * mfi_build_syspdio(struct mfi_softc *,struct bio*);
 static int	mfi_mapcmd(struct mfi_softc *, struct mfi_command *);
 static int	mfi_send_frame(struct mfi_softc *, struct mfi_command *);
 static void	mfi_complete(struct mfi_softc *, struct mfi_command *);
 static int	mfi_abort(struct mfi_softc *, struct mfi_command *);
-static int	mfi_linux_ioctl_int(struct cdev *, u_long, caddr_t, int, struct thread *);
+static int	mfi_linux_ioctl_int(struct cdev *, u_long, caddr_t, int, d_thread_t *);
+static int	mfi_alloc_skinny_memory(struct mfi_softc *sc);
+static void	mfi_free_skinny_memory(struct mfi_softc *sc);
 static void	mfi_timeout(void *);
-static int	mfi_user_command(struct mfi_softc *,
-		    struct mfi_ioc_passthru *);
 static void 	mfi_enable_intr_xscale(struct mfi_softc *sc);
 static void 	mfi_enable_intr_ppc(struct mfi_softc *sc);
 static int32_t 	mfi_read_fw_status_xscale(struct mfi_softc *sc);
@@ -128,11 +114,6 @@
 SYSCTL_INT(_hw_mfi, OID_AUTO, event_class, CTLFLAG_RW, &mfi_event_class,
           0, "event message class");
 
-static int	mfi_max_cmds = 128;
-TUNABLE_INT("hw.mfi.max_cmds", &mfi_max_cmds);
-SYSCTL_INT(_hw_mfi, OID_AUTO, max_cmds, CTLFLAG_RD, &mfi_max_cmds,
-	   0, "Max commands");
-
 /* Management interface */
 static d_open_t		mfi_open;
 static d_close_t	mfi_close;
@@ -152,6 +133,7 @@
 MALLOC_DEFINE(M_MFIBUF, "mfibuf", "Buffers for the MFI driver");
 
 #define MFI_INQ_LENGTH SHORT_INQUIRY_LENGTH
+struct mfi_skinny_dma_info mfi_skinny;
 
 static void
 mfi_enable_intr_xscale(struct mfi_softc *sc)
@@ -162,12 +144,17 @@
 static void
 mfi_enable_intr_ppc(struct mfi_softc *sc)
 {
-	MFI_WRITE4(sc, MFI_ODCR0, 0xFFFFFFFF);
 	if (sc->mfi_flags & MFI_FLAGS_1078) {
+		MFI_WRITE4(sc, MFI_ODCR0, 0xFFFFFFFF);
 		MFI_WRITE4(sc, MFI_OMSK, ~MFI_1078_EIM);
-	} else if (sc->mfi_flags & MFI_FLAGS_GEN2) {
+	}
+	else if (sc->mfi_flags & MFI_FLAGS_GEN2) {
+		MFI_WRITE4(sc, MFI_ODCR0, 0xFFFFFFFF);
 		MFI_WRITE4(sc, MFI_OMSK, ~MFI_GEN2_EIM);
 	}
+	else if (sc->mfi_flags & MFI_FLAGS_SKINNY) {
+		MFI_WRITE4(sc, MFI_OMSK, ~0x00000001);
+	}
 }
 
 static int32_t
@@ -175,14 +162,14 @@
 {
 	return MFI_READ4(sc, MFI_OMSG0);
 }
-
+ 
 static int32_t
 mfi_read_fw_status_ppc(struct mfi_softc *sc)
 {
 	return MFI_READ4(sc, MFI_OSP0);
 }
 
-static int
+static int 
 mfi_check_clear_intr_xscale(struct mfi_softc *sc)
 {
 	int32_t status;
@@ -193,9 +180,9 @@
 
 	MFI_WRITE4(sc, MFI_OSTS, status);
 	return 0;
-}
+ }
 
-static int
+static int 
 mfi_check_clear_intr_ppc(struct mfi_softc *sc)
 {
 	int32_t status;
@@ -205,35 +192,51 @@
 		if (!(status & MFI_1078_RM)) {
 			return 1;
 		}
-	} else if (sc->mfi_flags & MFI_FLAGS_GEN2) {
+	}
+	else if (sc->mfi_flags & MFI_FLAGS_GEN2) {
 		if (!(status & MFI_GEN2_RM)) {
 			return 1;
 		}
 	}
-
-	MFI_WRITE4(sc, MFI_ODCR0, status);
+	else if (sc->mfi_flags & MFI_FLAGS_SKINNY) {
+		if (!(status & MFI_SKINNY_RM)) {
+			return 1;
+		}
+	}
+	if (sc->mfi_flags & MFI_FLAGS_SKINNY)
+		MFI_WRITE4(sc, MFI_OSTS, status);
+	else
+		MFI_WRITE4(sc, MFI_ODCR0, status);
 	return 0;
-}
+ }
 
-static void
+static void 
 mfi_issue_cmd_xscale(struct mfi_softc *sc,uint32_t bus_add,uint32_t frame_cnt)
 {
 	MFI_WRITE4(sc, MFI_IQP,(bus_add >>3)|frame_cnt);
 }
-
-static void
+  
+static void 
 mfi_issue_cmd_ppc(struct mfi_softc *sc,uint32_t bus_add,uint32_t frame_cnt)
 {
-	MFI_WRITE4(sc, MFI_IQP, (bus_add |frame_cnt <<1)|1 );
+	if (sc->mfi_flags & MFI_FLAGS_SKINNY) {
+	    MFI_WRITE4(sc, MFI_IQPL, (bus_add |frame_cnt <<1)|1 );
+	    MFI_WRITE4(sc, MFI_IQPH, 0x00000000);
+	} else {
+	    MFI_WRITE4(sc, MFI_IQP, (bus_add |frame_cnt <<1)|1 );
+	}
 }
 
 static int
 mfi_transition_firmware(struct mfi_softc *sc)
 {
-	uint32_t fw_state, cur_state;
+	int32_t fw_state, cur_state;
 	int max_wait, i;
+	uint32_t cur_abs_reg_val = 0;
+	uint32_t prev_abs_reg_val = 0;
 
-	fw_state = sc->mfi_read_fw_status(sc)& MFI_FWSTATE_MASK;
+	cur_abs_reg_val = sc->mfi_read_fw_status(sc);
+	fw_state = cur_abs_reg_val & MFI_FWSTATE_MASK;
 	while (fw_state != MFI_FWSTATE_READY) {
 		if (bootverbose)
 			device_printf(sc->mfi_dev, "Waiting for firmware to "
@@ -244,11 +247,17 @@
 			device_printf(sc->mfi_dev, "Firmware fault\n");
 			return (ENXIO);
 		case MFI_FWSTATE_WAIT_HANDSHAKE:
-			MFI_WRITE4(sc, MFI_IDB, MFI_FWINIT_CLEAR_HANDSHAKE);
+			if (sc->mfi_flags & MFI_FLAGS_SKINNY)
+			    MFI_WRITE4(sc, MFI_SKINNY_IDB, MFI_FWINIT_CLEAR_HANDSHAKE);
+			else
+			    MFI_WRITE4(sc, MFI_IDB, MFI_FWINIT_CLEAR_HANDSHAKE);
 			max_wait = 2;
 			break;
 		case MFI_FWSTATE_OPERATIONAL:
-			MFI_WRITE4(sc, MFI_IDB, MFI_FWINIT_READY);
+			if (sc->mfi_flags & MFI_FLAGS_SKINNY)
+			    MFI_WRITE4(sc, MFI_SKINNY_IDB, MFI_FWINIT_READY);
+			else
+			    MFI_WRITE4(sc, MFI_IDB, MFI_FWINIT_READY);
 			max_wait = 10;
 			break;
 		case MFI_FWSTATE_UNDEFINED:
@@ -256,28 +265,42 @@
 			max_wait = 2;
 			break;
 		case MFI_FWSTATE_FW_INIT:
-		case MFI_FWSTATE_DEVICE_SCAN:
 		case MFI_FWSTATE_FLUSH_CACHE:
 			max_wait = 20;
 			break;
+		case MFI_FWSTATE_DEVICE_SCAN:
+			max_wait = 180; /* wait for 180 seconds */
+			prev_abs_reg_val = cur_abs_reg_val;
+			break;
 		case MFI_FWSTATE_BOOT_MESSAGE_PENDING:
-			MFI_WRITE4(sc, MFI_IDB, MFI_FWINIT_HOTPLUG);
+			if (sc->mfi_flags & MFI_FLAGS_SKINNY)
+			    MFI_WRITE4(sc, MFI_SKINNY_IDB, MFI_FWINIT_HOTPLUG);
+			else
+			    MFI_WRITE4(sc, MFI_IDB, MFI_FWINIT_HOTPLUG);
 			max_wait = 10;
 			break;
 		default:
-			device_printf(sc->mfi_dev,"Unknown firmware state %#x\n",
+			device_printf(sc->mfi_dev,"Unknown firmware state %x\n",
 			    fw_state);
 			return (ENXIO);
 		}
 		for (i = 0; i < (max_wait * 10); i++) {
-			fw_state = sc->mfi_read_fw_status(sc) & MFI_FWSTATE_MASK;
+			
+			cur_abs_reg_val = sc->mfi_read_fw_status(sc);
+			fw_state = cur_abs_reg_val & MFI_FWSTATE_MASK;
 			if (fw_state == cur_state)
 				DELAY(100000);
 			else
 				break;
 		}
+		if (fw_state == MFI_FWSTATE_DEVICE_SCAN) {
+			/* Check the device scanning progress */
+			if (prev_abs_reg_val != cur_abs_reg_val) {
+				continue;
+			}
+		}
 		if (fw_state == cur_state) {
-			device_printf(sc->mfi_dev, "Firmware stuck in state "
+			device_printf(sc->mfi_dev, "firmware stuck in state "
 			    "%#x\n", fw_state);
 			return (ENXIO);
 		}
@@ -300,12 +323,12 @@
 	uint32_t status;
 	int error, commsz, framessz, sensesz;
 	int frames, unit, max_fw_sge;
-
-	device_printf(sc->mfi_dev, "Megaraid SAS driver Ver 3.00 \n");
+	device_printf(sc->mfi_dev, "Megaraid SAS driver Ver 3.96 \n");
 
 	mtx_init(&sc->mfi_io_lock, "MFI I/O lock", NULL, MTX_DEF);
 	sx_init(&sc->mfi_config_lock, "MFI config");
 	TAILQ_INIT(&sc->mfi_ld_tqh);
+	TAILQ_INIT(&sc->mfi_syspd_tqh);
 	TAILQ_INIT(&sc->mfi_aen_pids);
 	TAILQ_INIT(&sc->mfi_cam_ccbq);
 
@@ -345,7 +368,7 @@
 	status = sc->mfi_read_fw_status(sc);
 	sc->mfi_max_fw_cmds = status & MFI_FWSTATE_MAXCMD_MASK;
 	max_fw_sge = (status & MFI_FWSTATE_MAXSGL_MASK) >> 16;
-	sc->mfi_max_sge = min(max_fw_sge, ((MFI_MAXPHYS / PAGE_SIZE) + 1));
+	sc->mfi_max_sge = min(max_fw_sge, ((MAXPHYS / PAGE_SIZE) + 1));
 
 	/*
 	 * Create the dma tag for data buffers.  Used both for block I/O
@@ -414,6 +437,8 @@
 	} else {
 		sc->mfi_sge_size = sizeof(struct mfi_sg32);
 	}
+	if (sc->mfi_flags & MFI_FLAGS_SKINNY)
+		sc->mfi_sge_size = sizeof(struct mfi_sg_skinny);
 	frames = (sc->mfi_sge_size * sc->mfi_max_sge - 1) / MFI_FRAME_SIZE + 2;
 	sc->mfi_cmd_size = frames * MFI_FRAME_SIZE;
 	framessz = sc->mfi_cmd_size * sc->mfi_max_fw_cmds;
@@ -470,6 +495,18 @@
 	if ((error = mfi_alloc_commands(sc)) != 0)
 		return (error);
 
+	/* Before moving the FW to operational state, check whether
+	 * hostmemory is required by the FW or not
+	 */
+	if (sc->mfi_flags & MFI_FLAGS_SKINNY) {
+		status = sc->mfi_read_fw_status(sc);
+		if (status & MFI_FWSTATE_HOSTMEMREQD_MASK) {
+			error = mfi_alloc_skinny_memory(sc);
+			if (error)
+				return error;
+		}
+	}
+
 	if ((error = mfi_comms_init(sc)) != 0)
 		return (error);
 
@@ -548,6 +585,230 @@
 	return (0);
 }
 
+static void
+mfi_skinny_addr32_cb(void *arg, bus_dma_segment_t *segs, int nsegs, int error)
+{
+	uint32_t *addr = (uint32_t *)arg;
+	if (error) {
+	    printf("mfi_skinny_addr32_cb: error=%d\n",error);
+	    return;
+	}
+	*addr = segs[0].ds_addr;
+	(mfi_skinny.noofmaps)++; 
+	return;
+}
+
+static void
+mfi_skinny_addr64_cb(void *arg, bus_dma_segment_t *segs, int nsegs, int error)
+{
+	uint32_t *addr = arg;
+	if (error) {
+	    printf("mfi_skinny_addr64_cb:error=%d\n",error);
+	    return;
+	}
+	*addr = segs[0].ds_addr;
+	(mfi_skinny.noofmaps)++; 
+	return;
+}
+
+/*
+ * FW requires 32MB of memory
+ * First try to allocate single 32MB chunk
+ * If it fails then try to allocate 512 chunks
+ * where each chunk is of 64K size
+ * FW expects the SGL of DCMD points to array of 64
+ * bit address chunks. Size of the address chunk and 
+ * number of address chunks will be indicated by 
+ * DCMD mbox fields 
+ */ 
+static int
+mfi_alloc_skinny_memory(struct mfi_softc *sc)
+{
+	struct mfi_command *cm = NULL;
+	struct mfi_dcmd_frame *dcmd = NULL;
+	uint32_t addr_32;
+	int error = 0;
+	int i = 0;
+	uint16_t *mbox;
+
+	mtx_lock(&sc->mfi_io_lock);
+	mfi_skinny.noofmaps = 0;
+	if((cm = mfi_dequeue_free(sc)) == NULL)
+	    return (EBUSY);
+	dcmd = &cm->cm_frame->dcmd;
+	bzero(dcmd->mbox, MFI_MBOX_SIZE);
+	dcmd->header.cmd = MFI_CMD_DCMD;
+	dcmd->opcode = MFI_DCMD_CTRL_MFI_HOST_MEM_ALLOC;
+	dcmd->header.flags = MFI_FRAME_DIR_WRITE;
+#define BUFLEN (512 * 8) /* 512  64 bit Addresses */
+	dcmd->header.data_len = 8;
+	dcmd->header.timeout = 0;
+	dcmd->header.sg_count = 1;
+	mbox = (uint16_t *) dcmd->mbox;
+	/* Allocate memory to store 64 bit addresses */
+	if (bus_dma_tag_create( NULL,	/* Parent */
+				1,0,			/* Alignment, boundary*/
+				BUS_SPACE_MAXADDR_32BIT,/* lowaddr */
+				BUS_SPACE_MAXADDR,	/* highaddr */
+				NULL, NULL,		/* filter, filterarg */
+				BUFLEN,			/* maxsize */
+				1,			/* msegments */
+				BUFLEN,			/* maxsegsize */
+				BUS_DMA_ALLOCNOW,	/* flags */
+				NULL, NULL,		/* lockfunc, lockarg */
+				&mfi_skinny.dmat[0])) {
+	    device_printf(sc->mfi_dev,"Cannot allocate DMA tag for address pointers\n");
+	    goto out;
+	}
+	if (bus_dmamem_alloc(mfi_skinny.dmat[0],(void **)&mfi_skinny.mem[0],
+	    BUS_DMA_NOWAIT|BUS_DMA_ZERO,&mfi_skinny.dmamap[0])) {
+	    device_printf(sc->mfi_dev,"Cannot alllocate DMA memory for address pointers\n");
+	    goto out;
+	}
+	error = bus_dmamap_load(mfi_skinny.dmat[0],mfi_skinny.dmamap[0],
+				(void *)(uint64_t)mfi_skinny.mem[0],BUFLEN,
+				mfi_skinny_addr32_cb,&dcmd->sgl.sg32[0].addr,
+				BUS_DMA_NOWAIT);
+	if (error ||  !mfi_skinny.noofmaps) {
+	    /* Map has not been loaded */
+	    device_printf(sc->mfi_dev,"Cannot load the DMA map for address pointers\n");
+	    goto out;
+	}
+	dcmd->sgl.sg32[0].len = 8;
+	device_printf(sc->mfi_dev,"DMA memory has been allocated and loaded for address pointers\n");
+	addr_32 = mfi_skinny.mem[0];
+	if (bus_dma_tag_create( NULL,			/* Parent */
+				32,0,			/* Alignment, boundary*/
+				BUS_SPACE_MAXADDR_32BIT,/* lowaddr */
+				BUS_SPACE_MAXADDR,	/* highaddr */
+				NULL, NULL,		/* filter, filterarg */
+				SKINNY_MEMORY,		/* maxsize */
+				1,			/* msegments */
+				SKINNY_MEMORY,		/* maxsegsize */
+				BUS_DMA_ALLOCNOW,	/* flags */
+				NULL, NULL,		/* lockfunc, lockarg */
+				&mfi_skinny.dmat[1])) {
+	    device_printf(sc->mfi_dev,"Cannot allocate 32MB SKINNY DMA tag\n");
+	    goto alloc_64K_chunks;
+	}
+	if (bus_dmamem_alloc(mfi_skinny.dmat[1],(void **)&mfi_skinny.mem[1],
+	    BUS_DMA_NOWAIT,&mfi_skinny.dmamap[1])) {
+	    device_printf(sc->mfi_dev,"Cannot alllocate 32MB DMA memory\n");
+	    goto alloc_64K_chunks;
+	}
+
+	/* Get the starting address where we need to put 64 bit addresses */
+	addr_32 = mfi_skinny.mem[0];
+	error = bus_dmamap_load(mfi_skinny.dmat[1],mfi_skinny.dmamap[1],
+		(void *)(uint64_t) mfi_skinny.mem[1],SKINNY_MEMORY,mfi_skinny_addr64_cb,
+		(void **)(uint64_t) addr_32,BUS_DMA_NOWAIT);
+	if (!error && mfi_skinny.noofmaps == 2) {
+	    /* Map has been loaded */
+	    device_printf(sc->mfi_dev,"32MB has been loaded in a single DMA segment\n");
+	   /* Fill remaining fields and fire the DCMD */
+	   device_printf(sc->mfi_dev,"32MB address is%ld\n",*(uint64_t *)(uint64_t) addr_32);
+	   bus_dmamap_sync(mfi_skinny.dmat[1], mfi_skinny.dmamap[1],
+				BUS_DMASYNC_PREWRITE);
+	   mbox[0] = 1; /* No of addresses in the array */
+	   mbox[2] = (SKINNY_MEMORY/1024); /* Size of chunk in KB */
+	   goto fire_cmd; 
+	}
+alloc_64K_chunks:
+	/* Try to allocate 64K chunks */
+#define MAX_CHUNKS 512
+#define CHUNK_SIZE (64*1024)
+	mbox[2] = 64; /* chunk size */
+	dcmd->header.data_len = 0;
+	dcmd->sgl.sg32[0].len = 0;
+	for (i=0; i < MAX_CHUNKS; i++) {
+		if (bus_dma_tag_create( NULL,	/* Parent */
+					32,0,	/* Alignment, boundary*/
+					BUS_SPACE_MAXADDR_32BIT,/* lowaddr */
+					BUS_SPACE_MAXADDR,	/* highaddr */
+					NULL, NULL,		/* filter, filterarg */
+					CHUNK_SIZE,		/* maxsize */
+					1,			/* msegments */
+					CHUNK_SIZE,		/* maxsegsize */
+					BUS_DMA_ALLOCNOW,	/* flags */
+					NULL, NULL,		/* lockfunc, lockarg */
+					&mfi_skinny.dmat[i+2])) {
+		    device_printf(sc->mfi_dev,"Cannot allocate 64K SKINNY DMA tag:%d\n",i);
+		    break;
+		}
+		if (bus_dmamem_alloc( mfi_skinny.dmat[i+2],
+				      (void **)&mfi_skinny.mem[i+2],
+				      BUS_DMA_NOWAIT,
+				      &mfi_skinny.dmamap[i+2])) {
+		    device_printf(sc->mfi_dev,"Cannot alllocate 64K DMA memory:%d\n",i);
+		    break;
+		}
+		error = bus_dmamap_load( mfi_skinny.dmat[i+2],
+					 mfi_skinny.dmamap[i+2],
+					 (void *)(uint64_t)mfi_skinny.mem[i+2],
+					 CHUNK_SIZE,
+					 mfi_skinny_addr64_cb,
+					 (void **)(uint64_t)addr_32,
+					 BUS_DMA_NOWAIT);
+		/* Point to next location */
+		addr_32 = addr_32 + sizeof(uint64_t);
+		if (error) {
+		    device_printf(sc->mfi_dev,"Cannot load 64K dmamap for:%d \n",i);
+		    break;
+		}
+		mbox[0] = i + 1; /* No of chunks mapped */
+		dcmd->header.data_len += 8;
+		dcmd->sgl.sg32[0].len += 8;
+	}
+	if (mfi_skinny.noofmaps >  MAX_CHUNKS) {
+	    /* All 512 chunks have been mapped */
+	    /* Fill remaining fields and fire the DCMD */
+	    device_printf(sc->mfi_dev,"All 512 chunks have been mapped\n");
+ 	    mbox[0] = MAX_CHUNKS; /* No of chunks */
+	}
+
+fire_cmd:
+	cm->cm_flags = MFI_CMD_POLLED;
+	error = mfi_send_frame(sc,cm);
+	if (!error &&
+	    cm->cm_frame->header.cmd_status != MFI_STAT_INVALID_CMD &&
+	    cm->cm_frame->header.cmd_status != MFI_STAT_INVALID_PARAMETER &&
+	    cm->cm_frame->header.cmd_status != MFI_STAT_WRONG_STATE)
+	    /* Command fired successfully */
+	    sc->mfi_skinny_cm = cm;
+
+out:
+	if (sc->mfi_skinny_cm) {
+	    device_printf(sc->mfi_dev,"Hostmemory DCMD fired successfully \n");
+	    mtx_unlock(&sc->mfi_io_lock);
+	    return 0;
+	}
+	/* Do clean up */
+	addr_32 = (uint32_t) mfi_skinny.mem[0];
+	for (i=1; i<mfi_skinny.noofmaps;i++) {
+		if (*(uint64_t *)(uint64_t)addr_32)
+		    bus_dmamap_unload(mfi_skinny.dmat[i],mfi_skinny.dmamap[i]);
+		if (mfi_skinny.mem[i])
+		    bus_dmamem_free (mfi_skinny.dmat[i],
+				     (void *)(uint64_t)mfi_skinny.mem[i],
+				     mfi_skinny.dmamap[i]);
+		if (mfi_skinny.dmat[i])
+		    bus_dma_tag_destroy(mfi_skinny.dmat[i]);
+		addr_32 += sizeof(uint64_t);
+	}
+	if (dcmd->sgl.sg32[0].addr)
+	    bus_dmamap_unload(mfi_skinny.dmat[0],mfi_skinny.dmamap[0]);
+	if (mfi_skinny.mem[0])
+	    bus_dmamem_free (mfi_skinny.dmat[0],
+			     (void *)(uint64_t)mfi_skinny.mem[0],
+			     mfi_skinny.dmamap[0]);
+	if (mfi_skinny.dmat[0])
+	    bus_dma_tag_destroy(mfi_skinny.dmat[0]);
+	mfi_release_command(cm);
+	mtx_unlock(&sc->mfi_io_lock);
+	return 0;
+}
+	
+	
 static int
 mfi_alloc_commands(struct mfi_softc *sc)
 {
@@ -558,11 +819,7 @@
 	 * XXX Should we allocate all the commands up front, or allocate on
 	 * demand later like 'aac' does?
 	 */
-	ncmds = MIN(mfi_max_cmds, sc->mfi_max_fw_cmds);
-	if (bootverbose)
-		device_printf(sc->mfi_dev, "Max fw cmds= %d, sizing driver "
-		   "pool to %d\n", sc->mfi_max_fw_cmds, ncmds);
-
+	ncmds = sc->mfi_max_fw_cmds;
 	sc->mfi_commands = malloc(sizeof(struct mfi_command) * ncmds, M_MFIBUF,
 	    M_WAITOK | M_ZERO);
 
@@ -629,6 +886,7 @@
 	struct mfi_command *cm;
 	struct mfi_dcmd_frame *dcmd;
 	void *buf = NULL;
+	uint32_t context = 0;
 	
 	mtx_assert(&sc->mfi_io_lock, MA_OWNED);
 	
@@ -636,6 +894,11 @@
 	if (cm == NULL)
 		return (EBUSY);
 
+	/* Zero out the MFI frame */
+	context = cm->cm_frame->header.context;
+	bzero(cm->cm_frame,sizeof (union mfi_frame));
+	cm->cm_frame->header.context = context;
+
 	if ((bufsize > 0) && (bufp != NULL)) {
 		if (*bufp == NULL) {
 			buf = malloc(bufsize, M_MFIBUF, M_NOWAIT|M_ZERO);
@@ -655,6 +918,7 @@
 	dcmd->header.timeout = 0;
 	dcmd->header.flags = 0;
 	dcmd->header.data_len = bufsize;
+	dcmd->header.scsi_status = 0;
 	dcmd->opcode = opcode;
 	cm->cm_sg = &dcmd->sgl;
 	cm->cm_total_frame_size = MFI_DCMD_FRAME_SIZE;
@@ -676,11 +940,17 @@
 	struct mfi_init_frame *init;
 	struct mfi_init_qinfo *qinfo;
 	int error;
+	uint32_t context = 0;
 
 	mtx_lock(&sc->mfi_io_lock);
 	if ((cm = mfi_dequeue_free(sc)) == NULL)
 		return (EBUSY);
 
+	/* Zero out the MFI frame */
+	context = cm->cm_frame->header.context;
+	bzero(cm->cm_frame,sizeof (union mfi_frame));
+	cm->cm_frame->header.context = context;
+
 	/*
 	 * Abuse the SG list area of the frame to hold the init_qinfo
 	 * object;
@@ -801,14 +1071,12 @@
 				free(log_state, M_MFIBUF);
 			return (error);
 		}
-
-		/*
-		 * Walk through any events that fired since the last
-		 * shutdown.
-		 */
-		mfi_parse_entries(sc, log_state->shutdown_seq_num,
-		    log_state->newest_seq_num);
-		seq = log_state->newest_seq_num;
+		/* The message log is a circular buffer */
+		for (seq = log_state->shutdown_seq_num;
+		     seq != log_state->newest_seq_num; seq++) {
+			mfi_get_entry(sc, seq);
+		}
+		mfi_get_entry(sc, seq);
 	} else
 		seq = seq_start;
 	mfi_aen_register(sc, seq, class_locale.word);
@@ -840,6 +1108,38 @@
 		msleep(cm, &sc->mfi_io_lock, PRIBIO, "mfiwait", 0);
 	return (cm->cm_error);
 }
+static void
+mfi_free_skinny_memory(struct mfi_softc *sc)
+{
+	int i = 0;
+	uint32_t addr_32;
+	struct mfi_dcmd_frame *dcmd = NULL;
+
+	if(!sc->mfi_skinny_cm)
+	   return;
+	dcmd = &sc->mfi_skinny_cm->cm_frame->dcmd;
+	addr_32 = (uint32_t) mfi_skinny.mem[0];
+	for (i=1; i<mfi_skinny.noofmaps;i++) {
+		if (*(uint64_t *)(uint64_t)addr_32)
+		    bus_dmamap_unload(mfi_skinny.dmat[i],mfi_skinny.dmamap[i]);
+		if (mfi_skinny.mem[i])
+		    bus_dmamem_free (mfi_skinny.dmat[i],
+				     (void *)(uint64_t)mfi_skinny.mem[i],
+				     mfi_skinny.dmamap[i]);
+		if (mfi_skinny.dmat[i])
+		    bus_dma_tag_destroy(mfi_skinny.dmat[i]);
+		addr_32 += sizeof(uint64_t);
+	}
+	if (dcmd->sgl.sg32[0].addr)
+	    bus_dmamap_unload(mfi_skinny.dmat[0],mfi_skinny.dmamap[0]);
+	if (mfi_skinny.mem[0])
+	    bus_dmamem_free (mfi_skinny.dmat[0],
+			     (void *)(uint64_t)mfi_skinny.mem[0],
+			     mfi_skinny.dmamap[0]);
+	if (mfi_skinny.dmat[0])
+	    bus_dma_tag_destroy(mfi_skinny.dmat[0]);
+	mfi_release_command(sc->mfi_skinny_cm);
+}
 
 void
 mfi_free(struct mfi_softc *sc)
@@ -851,6 +1151,8 @@
 
 	if (sc->mfi_cdev != NULL)
 		destroy_dev(sc->mfi_cdev);
+	if (sc->mfi_flags & MFI_FLAGS_SKINNY)
+	    mfi_free_skinny_memory(sc);
 
 	if (sc->mfi_total_cmds != 0) {
 		for (i = 0; i < sc->mfi_total_cmds; i++) {
@@ -916,6 +1218,8 @@
 	sx_xlock(&sc->mfi_config_lock);
 	mtx_lock(&sc->mfi_io_lock);
 	mfi_ldprobe(sc);
+	if (sc->mfi_flags & MFI_FLAGS_SKINNY)
+	    mfi_syspdprobe(sc);
 	mtx_unlock(&sc->mfi_io_lock);
 	sx_xunlock(&sc->mfi_config_lock);
 }
@@ -932,12 +1236,6 @@
 	if (sc->mfi_check_clear_intr(sc))
 		return;
 
-	/*
-	 * Do a dummy read to flush the interrupt ACK that we just performed,
-	 * ensuring that everything is really, truly consistent.
-	 */
-	(void)sc->mfi_read_fw_status(sc);
-
 	pi = sc->mfi_comms->hw_pi;
 	ci = sc->mfi_comms->hw_ci;
 	mtx_lock(&sc->mfi_io_lock);
@@ -995,6 +1293,76 @@
 	mtx_unlock(&sc->mfi_io_lock);
 	return (error);
 }
+static void
+mfi_syspdprobe(struct mfi_softc *sc)
+{
+	struct mfi_frame_header *hdr;
+	struct mfi_command *cm = NULL;
+	struct mfi_pd_list *pdlist = NULL;
+	struct mfi_system_pd *syspd;
+	int error, i;
+
+	sx_assert(&sc->mfi_config_lock,SA_XLOCKED);
+	mtx_assert(&sc->mfi_io_lock,MA_OWNED);
+	/* Add SYSTEM PD's */
+	error = mfi_dcmd_command(sc, &cm, MFI_DCMD_PD_LIST_QUERY,
+	    (void **)&pdlist, sizeof(*pdlist));
+	if (error){
+	    device_printf(sc->mfi_dev,"Error while forming SYSTEM PD list\n");
+	    goto out;
+	}
+	 
+	cm->cm_flags = MFI_CMD_DATAIN | MFI_CMD_POLLED;
+	cm->cm_frame->dcmd.mbox[0] = MR_PD_QUERY_TYPE_EXPOSED_TO_HOST;
+	cm->cm_frame->dcmd.mbox[1] = 0;
+	if (mfi_mapcmd(sc, cm) != 0) {
+	    device_printf(sc->mfi_dev, "Failed to get syspd device listing\n");
+	    goto out;
+	}
+	bus_dmamap_sync(sc->mfi_buffer_dmat,cm->cm_dmamap,
+		BUS_DMASYNC_POSTREAD);
+	bus_dmamap_unload(sc->mfi_buffer_dmat, cm->cm_dmamap);
+	hdr = &cm->cm_frame->header;
+	if (hdr->cmd_status != MFI_STAT_OK) {
+	    device_printf(sc->mfi_dev, "MFI_DCMD_PD_LIST_QUERY failed %x\n",
+			  hdr->cmd_status);
+	    goto out;
+	}
+	for (i=0;i<pdlist->count;i++) {
+	    if(pdlist->addr[i].device_id == pdlist->addr[i].encl_device_id)
+		goto skip_sys_pd_add;
+	    /* Get each PD and add it to the system */
+	    if (!TAILQ_EMPTY(&sc->mfi_syspd_tqh)) {
+	        TAILQ_FOREACH(syspd, &sc->mfi_syspd_tqh,pd_link) {
+		if (syspd->pd_id == pdlist->addr[i].device_id)
+		    goto skip_sys_pd_add;
+	        }
+	    }
+	    mfi_add_sys_pd(sc,pdlist->addr[i].device_id);
+	    skip_sys_pd_add:;
+	
+	}
+	/* Delete SYSPD's whose state has been changed */
+	if (!TAILQ_EMPTY(&sc->mfi_syspd_tqh)) {
+	    TAILQ_FOREACH(syspd, &sc->mfi_syspd_tqh,pd_link) {
+			for (i=0;i<pdlist->count;i++) {
+				if (syspd->pd_id == pdlist->addr[i].device_id)
+				    goto skip_sys_pd_delete;
+			}
+			mtx_lock(&Giant);
+			device_delete_child(sc->mfi_dev,syspd->pd_dev);
+			mtx_unlock(&Giant);
+skip_sys_pd_delete:;
+		}
+	}
+out:
+	if (pdlist)
+	    free(pdlist, M_MFIBUF);
+	if (cm)
+	    mfi_release_command(cm);
+
+	return;
+}
 
 static void
 mfi_ldprobe(struct mfi_softc *sc)
@@ -1043,59 +1411,350 @@
 	return;
 }
 
-/*
- * The timestamp is the number of seconds since 00:00 Jan 1, 2000.  If
- * the bits in 24-31 are all set, then it is the number of seconds since
- * boot.
- */
-static const char *
-format_timestamp(uint32_t timestamp)
-{
-	static char buffer[32];
-
-	if ((timestamp & 0xff000000) == 0xff000000)
-		snprintf(buffer, sizeof(buffer), "boot + %us", timestamp &
-		    0x00ffffff);
-	else
-		snprintf(buffer, sizeof(buffer), "%us", timestamp);
-	return (buffer);
-}
-
-static const char *
-format_class(int8_t class)
+static void
+mfi_decode_evt(struct mfi_softc *sc, struct mfi_evt_detail *detail,uint8_t probe_sys_pd)
 {
-	static char buffer[6];
-
-	switch (class) {
-	case MFI_EVT_CLASS_DEBUG:
-		return ("debug");
-	case MFI_EVT_CLASS_PROGRESS:
-		return ("progress");
-	case MFI_EVT_CLASS_INFO:
-		return ("info");
-	case MFI_EVT_CLASS_WARNING:
-		return ("WARN");
-	case MFI_EVT_CLASS_CRITICAL:
-		return ("CRIT");
-	case MFI_EVT_CLASS_FATAL:
-		return ("FATAL");
-	case MFI_EVT_CLASS_DEAD:
-		return ("DEAD");
+	struct mfi_system_pd *syspd = NULL;
+	switch (detail->arg_type) {
+	case MR_EVT_ARGS_NONE:
+#define MR_EVT_CTRL_HOST_BUS_SCAN_REQUESTED 0x0152
+		device_printf(sc->mfi_dev, "%d (%us/0x%04x/%d) - %s\n",
+		    detail->seq,
+		    detail->time,
+		    detail->evt_class.members.locale,
+		    detail->evt_class.members.evt_class,
+		    detail->description
+		    );
+		if (detail->code == MR_EVT_CTRL_HOST_BUS_SCAN_REQUESTED) {
+		    device_printf(sc->mfi_dev,"HostBus scan raised\n");
+		    if (probe_sys_pd) {
+			/* Probe for new SYSPD's and Delete invalid SYSPD's */
+			sx_xlock(&sc->mfi_config_lock);
+			mtx_lock(&sc->mfi_io_lock);
+			mfi_syspdprobe(sc);
+			mtx_unlock(&sc->mfi_io_lock);
+			sx_xunlock(&sc->mfi_config_lock);
+		    }
+		}
+		break;
+	case MR_EVT_ARGS_CDB_SENSE:
+		device_printf(sc->mfi_dev, "%d (%us/0x%04x/%d) - PD %02d(e%d/s%d) CDB %*D"
+		    "Sense %*D\n: %s\n",
+		    detail->seq,
+		    detail->time,
+		    detail->evt_class.members.locale,
+		    detail->evt_class.members.evt_class,
+		    detail->args.cdb_sense.pd.device_id,
+		    detail->args.cdb_sense.pd.enclosure_index,
+		    detail->args.cdb_sense.pd.slot_number,
+		    detail->args.cdb_sense.cdb_len,
+		    detail->args.cdb_sense.cdb,
+		    ":",
+		    detail->args.cdb_sense.sense_len,
+		    detail->args.cdb_sense.sense,
+		    ":",
+		    detail->description
+		    );
+		break;
+	case MR_EVT_ARGS_LD:
+		device_printf(sc->mfi_dev, "%d (%us/0x%04x/%d) - VD %02d/%d "
+		    "event: %s\n",
+		    detail->seq,
+		    detail->time,
+		    detail->evt_class.members.locale,
+		    detail->evt_class.members.evt_class,
+		    detail->args.ld.ld_index,
+		    detail->args.ld.target_id,
+		    detail->description
+		    );
+		break;
+	case MR_EVT_ARGS_LD_COUNT:
+		device_printf(sc->mfi_dev, "%d (%us/0x%04x/%d) - VD %02d/%d "
+		    "count %lld: %s\n",
+		    detail->seq,
+		    detail->time,
+		    detail->evt_class.members.locale,
+		    detail->evt_class.members.evt_class,
+		    detail->args.ld_count.ld.ld_index,
+		    detail->args.ld_count.ld.target_id,
+		    (long long)detail->args.ld_count.count,
+		    detail->description
+		    );
+		break;
+	case MR_EVT_ARGS_LD_LBA:
+		device_printf(sc->mfi_dev, "%d (%us/0x%04x/%d) - VD %02d/%d "
+		    "lba %lld: %s\n",
+		    detail->seq,
+		    detail->time,
+		    detail->evt_class.members.locale,
+		    detail->evt_class.members.evt_class,
+		    detail->args.ld_lba.ld.ld_index,
+		    detail->args.ld_lba.ld.target_id,
+		    (long long)detail->args.ld_lba.lba,
+		    detail->description
+		    );
+		break;
+	case MR_EVT_ARGS_LD_OWNER:
+		device_printf(sc->mfi_dev, "%d (%us/0x%04x/%d) - VD %02d/%d "
+		    "owner changed: prior %d, new %d: %s\n",
+		    detail->seq,
+		    detail->time,
+		    detail->evt_class.members.locale,
+		    detail->evt_class.members.evt_class,
+		    detail->args.ld_owner.ld.ld_index,
+		    detail->args.ld_owner.ld.target_id,
+		    detail->args.ld_owner.pre_owner,
+		    detail->args.ld_owner.new_owner,
+		    detail->description
+		    );
+		break;
+	case MR_EVT_ARGS_LD_LBA_PD_LBA:
+		device_printf(sc->mfi_dev, "%d (%us/0x%04x/%d) - VD %02d/%d "
+		    "lba %lld, physical drive PD %02d(e%d/s%d) lba %lld: %s\n",
+		    detail->seq,
+		    detail->time,
+		    detail->evt_class.members.locale,
+		    detail->evt_class.members.evt_class,
+		    detail->args.ld_lba_pd_lba.ld.ld_index,
+		    detail->args.ld_lba_pd_lba.ld.target_id,
+		    (long long)detail->args.ld_lba_pd_lba.ld_lba,
+		    detail->args.ld_lba_pd_lba.pd.device_id,
+		    detail->args.ld_lba_pd_lba.pd.enclosure_index,
+		    detail->args.ld_lba_pd_lba.pd.slot_number,
+		    (long long)detail->args.ld_lba_pd_lba.pd_lba,
+		    detail->description
+		    );
+		break;
+	case MR_EVT_ARGS_LD_PROG:
+		device_printf(sc->mfi_dev, "%d (%us/0x%04x/%d) - VD %02d/%d "
+		    "progress %d%% in %ds: %s\n",
+		    detail->seq,
+		    detail->time,
+		    detail->evt_class.members.locale,
+		    detail->evt_class.members.evt_class,
+		    detail->args.ld_prog.ld.ld_index,
+		    detail->args.ld_prog.ld.target_id,
+		    detail->args.ld_prog.prog.progress/655,
+		    detail->args.ld_prog.prog.elapsed_seconds,
+		    detail->description
+		    );
+		break;
+	case MR_EVT_ARGS_LD_STATE:
+		device_printf(sc->mfi_dev, "%d (%us/0x%04x/%d) - VD %02d/%d "
+		    "state prior %d new %d: %s\n",
+		    detail->seq,
+		    detail->time,
+		    detail->evt_class.members.locale,
+		    detail->evt_class.members.evt_class,
+		    detail->args.ld_state.ld.ld_index,
+		    detail->args.ld_state.ld.target_id,
+		    detail->args.ld_state.prev_state,
+		    detail->args.ld_state.new_state,
+		    detail->description
+		    );
+		/* During load time driver reads all the events starting from the one that
+		 * has been logged after shutdown. Avoid these old events.
+		 */        
+		if (!TAILQ_EMPTY(&sc->mfi_ld_tqh)) {
+			if (detail->args.ld_state.new_state == MFI_LD_STATE_OFFLINE ) {
+				/* Remove the LD */
+				struct mfi_disk *ld = NULL;
+				TAILQ_FOREACH(ld, &sc->mfi_ld_tqh, ld_link) {
+					if (ld->ld_id == detail->args.ld_state.ld.target_id)
+						break;
+				}
+				KASSERT(ld != NULL, ("volume dissappeared"));
+				mtx_lock(&Giant);
+				device_delete_child(sc->mfi_dev, ld->ld_dev);
+				mtx_unlock(&Giant);
+			}
+		} 
+		break;
+	case MR_EVT_ARGS_LD_STRIP:
+		device_printf(sc->mfi_dev, "%d (%us/0x%04x/%d) - VD %02d/%d "
+		    "strip %lld: %s\n",
+		    detail->seq,
+		    detail->time,
+		    detail->evt_class.members.locale,
+		    detail->evt_class.members.evt_class,
+		    detail->args.ld_strip.ld.ld_index,
+		    detail->args.ld_strip.ld.target_id,
+		    (long long)detail->args.ld_strip.strip,
+		    detail->description
+		    );
+		break;
+	case MR_EVT_ARGS_PD:
+#define MR_EVT_PD_REMOVED  0x0070
+#define MR_EVT_PD_INSERTED 0x005b
+		device_printf(sc->mfi_dev, "%d (%us/0x%04x/%d) - PD %02d(e%d/s%d) "
+		    "event: %s\n",
+		    detail->seq,
+		    detail->time,
+		    detail->evt_class.members.locale,
+		    detail->evt_class.members.evt_class,
+		    detail->args.pd.device_id,
+		    detail->args.pd.enclosure_index,
+		    detail->args.pd.slot_number,
+		    detail->description
+		    );
+		if (detail->code == MR_EVT_PD_REMOVED) {
+		    if (probe_sys_pd) {
+		    	/* If the removed device is a SYSPD then delete it */
+			if (!TAILQ_EMPTY(&sc->mfi_syspd_tqh)) {
+			    TAILQ_FOREACH(syspd,&sc->mfi_syspd_tqh,pd_link) {
+				if (syspd->pd_id == detail->args.pd.device_id) {
+					mtx_lock(&Giant);
+					device_delete_child(sc->mfi_dev,syspd->pd_dev);
+					mtx_unlock(&Giant);
+					break;
+				}
+			   }
+			} 
+		    }
+		}
+		if (detail->code == MR_EVT_PD_INSERTED) {
+		    if (probe_sys_pd) {
+		    	/* Probe for new SYSPD's */
+		    	sx_xlock(&sc->mfi_config_lock);
+		    	mtx_lock(&sc->mfi_io_lock);
+		    	mfi_syspdprobe(sc);
+		    	mtx_unlock(&sc->mfi_io_lock);
+		    	sx_xunlock(&sc->mfi_config_lock);
+		    }
+		}
+		break;
+	case MR_EVT_ARGS_PD_ERR:
+		device_printf(sc->mfi_dev, "%d (%us/0x%04x/%d) - PD %02d(e%d/s%d) "
+		    "err %d: %s\n",
+		    detail->seq,
+		    detail->time,
+		    detail->evt_class.members.locale,
+		    detail->evt_class.members.evt_class,
+		    detail->args.pd_err.pd.device_id,
+		    detail->args.pd_err.pd.enclosure_index,
+		    detail->args.pd_err.pd.slot_number,
+		    detail->args.pd_err.err,
+		    detail->description
+		    );
+		break;
+	case MR_EVT_ARGS_PD_LBA:
+		device_printf(sc->mfi_dev, "%d (%us/0x%04x/%d) - PD %02d(e%d/s%d) "
+		    "lba %lld: %s\n",
+		    detail->seq,
+		    detail->time,
+		    detail->evt_class.members.locale,
+		    detail->evt_class.members.evt_class,
+		    detail->args.pd_lba.pd.device_id,
+		    detail->args.pd_lba.pd.enclosure_index,
+		    detail->args.pd_lba.pd.slot_number,
+		    (long long)detail->args.pd_lba.lba,
+		    detail->description
+		    );
+		break;
+	case MR_EVT_ARGS_PD_LBA_LD:
+		device_printf(sc->mfi_dev, "%d (%us/0x%04x/%d) - PD %02d(e%d/s%d) "
+		    "lba %lld VD %02d/%d: %s\n",
+		    detail->seq,
+		    detail->time,
+		    detail->evt_class.members.locale,
+		    detail->evt_class.members.evt_class,
+		    detail->args.pd_lba_ld.pd.device_id,
+		    detail->args.pd_lba_ld.pd.enclosure_index,
+		    detail->args.pd_lba_ld.pd.slot_number,
+		    (long long)detail->args.pd_lba.lba,
+		    detail->args.pd_lba_ld.ld.ld_index,
+		    detail->args.pd_lba_ld.ld.target_id,
+		    detail->description
+		    );
+		break;
+	case MR_EVT_ARGS_PD_PROG:
+		device_printf(sc->mfi_dev, "%d (%us/0x%04x/%d) - PD %02d(e%d/s%d) "
+		    "progress %d%% seconds %ds: %s\n",
+		    detail->seq,
+		    detail->time,
+		    detail->evt_class.members.locale,
+		    detail->evt_class.members.evt_class,
+		    detail->args.pd_prog.pd.device_id,
+		    detail->args.pd_prog.pd.enclosure_index,
+		    detail->args.pd_prog.pd.slot_number,
+		    detail->args.pd_prog.prog.progress/655,
+		    detail->args.pd_prog.prog.elapsed_seconds,
+		    detail->description
+		    );
+		break;
+	case MR_EVT_ARGS_PD_STATE:
+		device_printf(sc->mfi_dev, "%d (%us/0x%04x/%d) - PD %02d(e%d/s%d) "
+		    "state prior %d new %d: %s\n",
+		    detail->seq,
+		    detail->time,
+		    detail->evt_class.members.locale,
+		    detail->evt_class.members.evt_class,
+		    detail->args.pd_prog.pd.device_id,
+		    detail->args.pd_prog.pd.enclosure_index,
+		    detail->args.pd_prog.pd.slot_number,
+		    detail->args.pd_state.prev_state,
+		    detail->args.pd_state.new_state,
+		    detail->description
+		    );
+		break;
+	case MR_EVT_ARGS_PCI:
+		device_printf(sc->mfi_dev, "%d (%us/0x%04x/%d) - PCI 0x04%x 0x04%x "
+		    "0x04%x 0x04%x: %s\n",
+		    detail->seq,
+		    detail->time,
+		    detail->evt_class.members.locale,
+		    detail->evt_class.members.evt_class,
+		    detail->args.pci.venderId,
+		    detail->args.pci.deviceId,
+		    detail->args.pci.subVenderId,
+		    detail->args.pci.subDeviceId,
+		    detail->description
+		    );
+		break;
+	case MR_EVT_ARGS_RATE:
+		device_printf(sc->mfi_dev, "%d (%us/0x%04x/%d) : %s\n",
+		    detail->seq,
+		    detail->time,
+		    detail->evt_class.members.locale,
+		    detail->evt_class.members.evt_class,
+		    detail->description
+		    );
+		break;
+	case MR_EVT_ARGS_TIME:
+		device_printf(sc->mfi_dev, "%d (%us/0x%04x/%d) - Adapter ticks %d "
+		    "elapsed %ds: %s\n",
+		    detail->seq,
+		    detail->time,
+		    detail->evt_class.members.locale,
+		    detail->evt_class.members.evt_class,
+		    detail->args.time.rtc,
+		    detail->args.time.elapsedSeconds,
+		    detail->description
+		    );
+		break;
+	case MR_EVT_ARGS_ECC:
+		device_printf(sc->mfi_dev, "%d (%us/0x%04x/%d) - Adapter ECC %x,%x: %s: %s\n",
+		    detail->seq,
+		    detail->time,
+		    detail->evt_class.members.locale,
+		    detail->evt_class.members.evt_class,
+		    detail->args.ecc.ecar,
+		    detail->args.ecc.elog,
+		    detail->args.ecc.str,
+		    detail->description
+		    );
+		break;
 	default:
-		snprintf(buffer, sizeof(buffer), "%d", class);
-		return (buffer);
+		device_printf(sc->mfi_dev, "%d (%us/0x%04x/%d) - Type %d: %s\n",
+		    detail->seq,
+		    detail->time,
+		    detail->evt_class.members.locale,
+		    detail->evt_class.members.evt_class,
+		    detail->arg_type, detail->description
+		    );
 	}
 }
 
-static void
-mfi_decode_evt(struct mfi_softc *sc, struct mfi_evt_detail *detail)
-{
-
-	device_printf(sc->mfi_dev, "%d (%s/0x%04x/%s) - %s\n", detail->seq,
-	    format_timestamp(detail->time), detail->evt_class.members.locale,
-	    format_class(detail->evt_class.members.evt_class), detail->description);
-}
-
 static int
 mfi_aen_register(struct mfi_softc *sc, int seq, int locale)
 {
@@ -1159,8 +1818,7 @@
 	if (sc->mfi_aen_cm == NULL)
 		return;
 
-	if (sc->mfi_aen_cm->cm_aen_abort ||
-	    hdr->cmd_status == MFI_STAT_INVALID_STATUS) {
+	if (sc->mfi_aen_cm->cm_aen_abort || hdr->cmd_status == 0xff) {
 		sc->mfi_aen_cm->cm_aen_abort = 0;
 		aborted = 1;
 	} else {
@@ -1174,7 +1832,9 @@
 		 * XXX If this function is too expensive or is recursive, then
 		 * events should be put onto a queue and processed later.
 		 */
-		mfi_decode_evt(sc, detail);
+		mtx_unlock(&sc->mfi_io_lock);
+		mfi_decode_evt(sc, detail,1);
+		mtx_lock(&sc->mfi_io_lock);
 		seq = detail->seq + 1;
 		TAILQ_FOREACH_SAFE(mfi_aen_entry, &sc->mfi_aen_pids, aen_link, tmp) {
 			TAILQ_REMOVE(&sc->mfi_aen_pids, mfi_aen_entry,
@@ -1197,91 +1857,73 @@
 	}
 }
 
-#define MAX_EVENTS 15
-
+/* Only do one event for now so we can easily iterate through them */
+#define MAX_EVENTS 1
 static int
-mfi_parse_entries(struct mfi_softc *sc, int start_seq, int stop_seq)
+mfi_get_entry(struct mfi_softc *sc, int seq)
 {
 	struct mfi_command *cm;
 	struct mfi_dcmd_frame *dcmd;
 	struct mfi_evt_list *el;
-	union mfi_evt class_locale;
-	int error, i, seq, size;
+	int error;
+	int i;
+	int size;
+	uint32_t context = 0;
 
-	class_locale.members.reserved = 0;
-	class_locale.members.locale = mfi_event_locale;
-	class_locale.members.evt_class  = mfi_event_class;
+	if ((cm = mfi_dequeue_free(sc)) == NULL) {
+		return (EBUSY);
+	}
+
+	/* Zero out the MFI frame */
+	context = cm->cm_frame->header.context;
+	bzero(cm->cm_frame,sizeof (union mfi_frame));
+	cm->cm_frame->header.context = context;
 
 	size = sizeof(struct mfi_evt_list) + sizeof(struct mfi_evt_detail)
 		* (MAX_EVENTS - 1);
 	el = malloc(size, M_MFIBUF, M_NOWAIT | M_ZERO);
-	if (el == NULL)
+	if (el == NULL) {
+		mfi_release_command(cm);
 		return (ENOMEM);
+	}
 
-	for (seq = start_seq;;) {
-		if ((cm = mfi_dequeue_free(sc)) == NULL) {
-			free(el, M_MFIBUF);
-			return (EBUSY);
-		}
-
-		dcmd = &cm->cm_frame->dcmd;
-		bzero(dcmd->mbox, MFI_MBOX_SIZE);
-		dcmd->header.cmd = MFI_CMD_DCMD;
-		dcmd->header.timeout = 0;
-		dcmd->header.data_len = size;
-		dcmd->opcode = MFI_DCMD_CTRL_EVENT_GET;
-		((uint32_t *)&dcmd->mbox)[0] = seq;
-		((uint32_t *)&dcmd->mbox)[1] = class_locale.word;
-		cm->cm_sg = &dcmd->sgl;
-		cm->cm_total_frame_size = MFI_DCMD_FRAME_SIZE;
-		cm->cm_flags = MFI_CMD_DATAIN | MFI_CMD_POLLED;
-		cm->cm_data = el;
-		cm->cm_len = size;
-
-		if ((error = mfi_mapcmd(sc, cm)) != 0) {
-			device_printf(sc->mfi_dev,
-			    "Failed to get controller entries\n");
-			mfi_release_command(cm);
-			break;
-		}
-
-		bus_dmamap_sync(sc->mfi_buffer_dmat, cm->cm_dmamap,
-		    BUS_DMASYNC_POSTREAD);
-		bus_dmamap_unload(sc->mfi_buffer_dmat, cm->cm_dmamap);
+	dcmd = &cm->cm_frame->dcmd;
+	bzero(dcmd->mbox, MFI_MBOX_SIZE);
+	dcmd->header.cmd = MFI_CMD_DCMD;
+	dcmd->header.timeout = 0;
+	dcmd->header.data_len = size;
+	dcmd->header.scsi_status = 0;
+	dcmd->opcode = MFI_DCMD_CTRL_EVENT_GET;
+	((uint32_t *)&dcmd->mbox)[0] = seq;
+	((uint32_t *)&dcmd->mbox)[1] = MFI_EVT_LOCALE_ALL;
+	cm->cm_sg = &dcmd->sgl;
+	cm->cm_total_frame_size = MFI_DCMD_FRAME_SIZE;
+	cm->cm_flags = MFI_CMD_DATAIN | MFI_CMD_POLLED;
+	cm->cm_data = el;
+	cm->cm_len = size;
 
-		if (dcmd->header.cmd_status == MFI_STAT_NOT_FOUND) {
-			mfi_release_command(cm);
-			break;
-		}
-		if (dcmd->header.cmd_status != MFI_STAT_OK) {
-			device_printf(sc->mfi_dev,
-			    "Error %d fetching controller entries\n",
-			    dcmd->header.cmd_status);
-			mfi_release_command(cm);
-			break;
-		}
+	if ((error = mfi_mapcmd(sc, cm)) != 0) {
+		device_printf(sc->mfi_dev, "Failed to get controller entry\n");
+		sc->mfi_max_io = (sc->mfi_max_sge - 1) * PAGE_SIZE /
+		    MFI_SECTOR_LEN;
+		free(el, M_MFIBUF);
 		mfi_release_command(cm);
+		return (0);
+	}
 
+	bus_dmamap_sync(sc->mfi_buffer_dmat, cm->cm_dmamap,
+	    BUS_DMASYNC_POSTREAD);
+	bus_dmamap_unload(sc->mfi_buffer_dmat, cm->cm_dmamap);
+
+	if (dcmd->header.cmd_status != MFI_STAT_NOT_FOUND) {
 		for (i = 0; i < el->count; i++) {
-			/*
-			 * If this event is newer than 'stop_seq' then
-			 * break out of the loop.  Note that the log
-			 * is a circular buffer so we have to handle
-			 * the case that our stop point is earlier in
-			 * the buffer than our start point.
-			 */
-			if (el->event[i].seq >= stop_seq) {
-				if (start_seq <= stop_seq)
-					break;
-				else if (el->event[i].seq < start_seq)
-					break;
-			}
-			mfi_decode_evt(sc, &el->event[i]);
+			if (seq + i == el->event[i].seq)
+				mfi_decode_evt(sc, &el->event[i],0);
 		}
-		seq = el->event[el->count - 1].seq + 1;
 	}
 
-	free(el, M_MFIBUF);
+	free(cm->cm_data, M_MFIBUF);
+	mfi_release_command(cm);
 	return (0);
 }
 
@@ -1313,8 +1955,10 @@
 		free(ld_info, M_MFIBUF);
 		return (0);
 	}
-
-	mfi_add_ld_complete(cm);
+	if (ld_info->ld_config.params.isSSCD != 1)
+		mfi_add_ld_complete(cm);
+	else
+		mfi_release_command(cm);
 	return (0);
 }
 
@@ -1354,22 +1998,181 @@
 	mtx_lock(&sc->mfi_io_lock);
 }
 
+static int mfi_add_sys_pd(struct mfi_softc *sc,int id)
+{
+	struct mfi_command *cm;
+	struct mfi_dcmd_frame *dcmd = NULL;
+	struct mfi_pd_info *pd_info = NULL;
+	int error;
+
+	mtx_assert(&sc->mfi_io_lock,MA_OWNED);
+
+	error = mfi_dcmd_command(sc,&cm,MFI_DCMD_PD_GET_INFO,
+		(void **)&pd_info, sizeof(*pd_info));
+	if (error) {
+	    device_printf(sc->mfi_dev,
+		"Failed to allocated for MFI_DCMD_PD_GET_INFO %d\n",error);
+	    if (pd_info)
+		free(pd_info,M_MFIBUF);
+	    return (error);
+	}
+	cm->cm_flags = MFI_CMD_DATAIN | MFI_CMD_POLLED;
+	dcmd = &cm->cm_frame->dcmd;
+	dcmd->mbox[0]=id;
+	dcmd->header.scsi_status = 0;
+	dcmd->header.pad0 = 0;
+	if (mfi_mapcmd(sc,cm) != 0) {
+	    device_printf(sc->mfi_dev,
+		"Failed to get physical drive info %d\n",id);
+	    free(pd_info,M_MFIBUF);
+	    return (0);
+	}
+	bus_dmamap_sync(sc->mfi_buffer_dmat,cm->cm_dmamap,BUS_DMASYNC_POSTREAD);
+	bus_dmamap_unload(sc->mfi_buffer_dmat,cm->cm_dmamap);
+	mfi_add_sys_pd_complete(cm);
+	return (0);
+}
+	    
+static void
+mfi_add_sys_pd_complete(struct mfi_command *cm)
+{
+	struct mfi_frame_header *hdr;
+	struct mfi_pd_info *pd_info;
+	struct mfi_softc *sc;
+	device_t child;
+
+	sc = cm->cm_sc;
+	hdr = &cm->cm_frame->header;
+	pd_info = cm->cm_private;
+
+	if (hdr->cmd_status != MFI_STAT_OK) {
+	    free(pd_info, M_MFIBUF);
+	    mfi_release_command(cm);
+	    return;
+	}
+	if (pd_info->fw_state != MFI_PD_STATE_SYSTEM) {
+	    device_printf(sc->mfi_dev,"PD=%x is not SYSTEM PD\n",
+			  pd_info->ref.v.device_id);
+	    free(pd_info, M_MFIBUF);
+	    mfi_release_command(cm);
+	    return;
+	}
+	mfi_release_command(cm);
+
+	mtx_unlock(&sc->mfi_io_lock);
+	mtx_lock(&Giant);
+	if ((child = device_add_child(sc->mfi_dev, "mfisyspd", -1)) == NULL) {
+	    device_printf(sc->mfi_dev, "Failed to add system pd\n");
+	    free(pd_info, M_MFIBUF);
+	    mtx_unlock(&Giant);
+	    mtx_lock(&sc->mfi_io_lock);
+	    return;
+	}
+
+	device_set_ivars(child, pd_info);
+	device_set_desc(child, "MFI System PD");
+	bus_generic_attach(sc->mfi_dev);
+	mtx_unlock(&Giant);
+	mtx_lock(&sc->mfi_io_lock);
+}
 static struct mfi_command *
 mfi_bio_command(struct mfi_softc *sc)
 {
-	struct mfi_io_frame *io;
-	struct mfi_command *cm;
 	struct bio *bio;
-	int flags, blkcount;
+	struct mfi_command *cm = NULL;
 
-	if ((cm = mfi_dequeue_free(sc)) == NULL)
+	/*reserving two commands to avoid starvation for IOCTL*/
+	if(sc->mfi_qstat[MFIQ_FREE].q_length < 2){
 		return (NULL);
-
+	}
 	if ((bio = mfi_dequeue_bio(sc)) == NULL) {
-		mfi_release_command(cm);
 		return (NULL);
 	}
+	if ((uint64_t)bio->bio_driver2 == MFI_LD_IO) {
+		cm = mfi_build_ldio(sc,bio);
+	} else if ((uint64_t) bio->bio_driver2 == MFI_SYS_PD_IO) {
+		cm = mfi_build_syspdio(sc,bio);
+	}
+	if (!cm)
+	    mfi_enqueue_bio(sc,bio);
+	return cm;
+}
+static struct mfi_command *
+mfi_build_syspdio(struct mfi_softc *sc,struct bio *bio)
+{
+	struct mfi_command *cm;
+	struct mfi_pass_frame *pass;
+	int flags = 0,blkcount = 0;
+	uint32_t context = 0;
+	
+	if ((cm = mfi_dequeue_free(sc)) == NULL)
+	    return (NULL);
+
+	/* Zero out the MFI frame */
+ 	context = cm->cm_frame->header.context;
+	bzero(cm->cm_frame,sizeof(union mfi_frame));
+	cm->cm_frame->header.context = context;		
+	pass = &cm->cm_frame->pass;
+	bzero(pass->cdb,16);
+	pass->header.cmd = MFI_CMD_PD_SCSI_IO;
+	switch (bio->bio_cmd & 0x03) {
+	case BIO_READ:
+#define SCSI_READ 0x28
+		pass->cdb[0] = SCSI_READ;
+		flags = MFI_CMD_DATAIN;
+		break;
+	case BIO_WRITE:
+#define SCSI_WRITE 0x2a
+		pass->cdb[0] = SCSI_WRITE;
+		flags = MFI_CMD_DATAOUT;
+		break;
+	default:
+		panic("Invalid bio command");
+	}
+	
+	/* Cheat with the sector length to avoid a non-constant division */
+	blkcount = (bio->bio_bcount + MFI_SECTOR_LEN - 1) / MFI_SECTOR_LEN;
+	/* Fill the LBA and Transfer length in CDB */
+	pass->cdb[2] = (bio->bio_pblkno & 0xff000000) >> 24;
+	pass->cdb[3] = (bio->bio_pblkno & 0x00ff0000) >> 16;
+	pass->cdb[4] = (bio->bio_pblkno & 0x0000ff00) >> 8;
+	pass->cdb[5] = bio->bio_pblkno & 0x000000ff;
+	pass->cdb[7] = (blkcount & 0xff00) >> 8;
+	pass->cdb[8] = (blkcount & 0x00ff);
+	pass->header.target_id = (uintptr_t)bio->bio_driver1;
+	pass->header.timeout = 0;
+	pass->header.flags = 0;
+	pass->header.scsi_status = 0;
+	pass->header.sense_len = MFI_SENSE_LEN;
+	pass->header.data_len = bio->bio_bcount;
+	pass->header.cdb_len = 10;
+	pass->sense_addr_lo = cm->cm_sense_busaddr;
+	pass->sense_addr_hi = 0;
+	cm->cm_complete = mfi_bio_complete;
+	cm->cm_private = bio;
+	cm->cm_data = bio->bio_data;
+	cm->cm_len = bio->bio_bcount;
+	cm->cm_sg = &pass->sgl;
+	cm->cm_total_frame_size = MFI_PASS_FRAME_SIZE;
+	cm->cm_flags = flags;
+	return (cm);
+}
+
+static struct mfi_command *
+mfi_build_ldio(struct mfi_softc *sc,struct bio *bio)
+{
+	struct mfi_io_frame *io;
+	struct mfi_command *cm;
+	int flags, blkcount;
+	uint32_t context = 0;
 
+	if ((cm = mfi_dequeue_free(sc)) == NULL)
+	    return (NULL);
+	
+	/* Zero out the MFI frame */
+ 	context = cm->cm_frame->header.context;
+	bzero(cm->cm_frame,sizeof(union mfi_frame));
+	cm->cm_frame->header.context = context;		
 	io = &cm->cm_frame->io;
 	switch (bio->bio_cmd & 0x03) {
 	case BIO_READ:
@@ -1389,6 +2192,7 @@
 	io->header.target_id = (uintptr_t)bio->bio_driver1;
 	io->header.timeout = 0;
 	io->header.flags = 0;
+	io->header.scsi_status = 0;
 	io->header.sense_len = MFI_SENSE_LEN;
 	io->header.data_len = blkcount;
 	io->sense_addr_lo = cm->cm_sense_busaddr;
@@ -1416,14 +2220,12 @@
 	hdr = &cm->cm_frame->header;
 	sc = cm->cm_sc;
 
-	if ((hdr->cmd_status != MFI_STAT_OK) || (hdr->scsi_status != 0)) {
+	if ((hdr->cmd_status != 0) || (hdr->scsi_status != 0)) {
 		bio->bio_flags |= BIO_ERROR;
 		bio->bio_error = EIO;
 		device_printf(sc->mfi_dev, "I/O error, status= %d "
 		    "scsi_status= %d\n", hdr->cmd_status, hdr->scsi_status);
 		mfi_print_sense(cm->cm_sc, cm->cm_sense);
-	} else if (cm->cm_error != 0) {
-		bio->bio_flags |= BIO_ERROR;
 	}
 
 	mfi_release_command(cm);
@@ -1494,7 +2296,9 @@
 	struct mfi_command *cm;
 	union mfi_sgl *sgl;
 	struct mfi_softc *sc;
-	int i, j, first, dir;
+	int i, dir;
+	int sgl_mapped = 0;
+	int sge_size = 0;
 
 	cm = (struct mfi_command *)arg;
 	sc = cm->cm_sc;
@@ -1507,34 +2311,42 @@
 		mfi_complete(sc, cm);
 		return;
 	}
-
-	j = 0;
-	if (cm->cm_frame->header.cmd == MFI_CMD_STP) {
-		first = cm->cm_stp_len;
+	/* Use IEEE sgl only for IO's on a SKINNY controller
+	 * For other commands on a SKINNY controller use either 
+	 * sg32 or sg64 based on the sizeof(bus_addr_t).
+	 * Also calculate the total frame size based on the type 
+	 * of SGL used.
+	 */
+	if (((cm->cm_frame->header.cmd == MFI_CMD_PD_SCSI_IO) ||
+	    (cm->cm_frame->header.cmd == MFI_CMD_LD_READ) ||
+	    (cm->cm_frame->header.cmd == MFI_CMD_LD_WRITE)) &&
+	    (sc->mfi_flags & MFI_FLAGS_SKINNY)) {
+		for (i = 0; i < nsegs; i++) {
+			sgl->sg_skinny[i].addr = segs[i].ds_addr;
+			sgl->sg_skinny[i].len = segs[i].ds_len;
+			sgl->sg_skinny[i].flag = 0;
+		}
+		hdr->flags |= MFI_FRAME_IEEE_SGL | MFI_FRAME_SGL64;
+		sgl_mapped = 1;
+		sge_size = sizeof(struct mfi_sg_skinny);
+	}
+	if (!sgl_mapped) {
 		if ((sc->mfi_flags & MFI_FLAGS_SG64) == 0) {
-			sgl->sg32[j].addr = segs[0].ds_addr;
-			sgl->sg32[j++].len = first;
+			for (i = 0; i < nsegs; i++) {
+				sgl->sg32[i].addr = segs[i].ds_addr;
+				sgl->sg32[i].len = segs[i].ds_len;
+			}
+			sge_size = sizeof(struct mfi_sg32);
 		} else {
-			sgl->sg64[j].addr = segs[0].ds_addr;
-			sgl->sg64[j++].len = first;
-		}
-	} else
-		first = 0;
-	if ((sc->mfi_flags & MFI_FLAGS_SG64) == 0) {
-		for (i = 0; i < nsegs; i++) {
-			sgl->sg32[j].addr = segs[i].ds_addr + first;
-			sgl->sg32[j++].len = segs[i].ds_len - first;
-			first = 0;
-		}
-	} else {
-		for (i = 0; i < nsegs; i++) {
-			sgl->sg64[j].addr = segs[i].ds_addr + first;
-			sgl->sg64[j++].len = segs[i].ds_len - first;
-			first = 0;
+			for (i = 0; i < nsegs; i++) {
+				sgl->sg64[i].addr = segs[i].ds_addr;
+				sgl->sg64[i].len = segs[i].ds_len;
+			}
+			hdr->flags |= MFI_FRAME_SGL64;
+			sge_size = sizeof(struct mfi_sg64);
 		}
-		hdr->flags |= MFI_FRAME_SGL64;
 	}
-	hdr->sg_count = j;
+	hdr->sg_count = nsegs;
 
 	dir = 0;
 	if (cm->cm_flags & MFI_CMD_DATAIN) {
@@ -1545,8 +2357,6 @@
 		dir |= BUS_DMASYNC_PREWRITE;
 		hdr->flags |= MFI_FRAME_DIR_WRITE;
 	}
-	if (cm->cm_frame->header.cmd == MFI_CMD_STP)
-		dir |= BUS_DMASYNC_PREWRITE;
 	bus_dmamap_sync(sc->mfi_buffer_dmat, cm->cm_dmamap, dir);
 	cm->cm_flags |= MFI_CMD_MAPPED;
 
@@ -1556,7 +2366,7 @@
 	 * least 1 frame, so don't compensate for the modulo of the
 	 * following division.
 	 */
-	cm->cm_total_frame_size += (sc->mfi_sge_size * nsegs);
+	cm->cm_total_frame_size += (sge_size * nsegs);
 	cm->cm_extra_frames = (cm->cm_total_frame_size - 1) / MFI_FRAME_SIZE;
 
 	mfi_send_frame(sc, cm);
@@ -1576,7 +2386,7 @@
 		cm->cm_timestamp = time_uptime;
 		mfi_enqueue_busy(cm);
 	} else {
-		hdr->cmd_status = MFI_STAT_INVALID_STATUS;
+		hdr->cmd_status = 0xff;
 		hdr->flags |= MFI_FRAME_DONT_POST_IN_REPLY_QUEUE;
 	}
 
@@ -1601,14 +2411,14 @@
 		return (0);
 
 	/* This is a polled command, so busy-wait for it to complete. */
-	while (hdr->cmd_status == MFI_STAT_INVALID_STATUS) {
+	while (hdr->cmd_status == 0xff) {
 		DELAY(1000);
 		tm -= 1;
 		if (tm <= 0)
 			break;
 	}
 
-	if (hdr->cmd_status == MFI_STAT_INVALID_STATUS) {
+	if (hdr->cmd_status == 0xff) {
 		device_printf(sc->mfi_dev, "Frame %p timed out "
 			      "command 0x%X\n", hdr, cm->cm_frame->dcmd.opcode);
 		return (ETIMEDOUT);
@@ -1624,8 +2434,7 @@
 
 	if ((cm->cm_flags & MFI_CMD_MAPPED) != 0) {
 		dir = 0;
-		if ((cm->cm_flags & MFI_CMD_DATAIN) ||
-		    (cm->cm_frame->header.cmd == MFI_CMD_STP))
+		if (cm->cm_flags & MFI_CMD_DATAIN)
 			dir |= BUS_DMASYNC_POSTREAD;
 		if (cm->cm_flags & MFI_CMD_DATAOUT)
 			dir |= BUS_DMASYNC_POSTWRITE;
@@ -1649,6 +2458,7 @@
 	struct mfi_command *cm;
 	struct mfi_abort_frame *abort;
 	int i = 0;
+	uint32_t context = 0;
 
 	mtx_assert(&sc->mfi_io_lock, MA_OWNED);
 
@@ -1656,9 +2466,15 @@
 		return (EBUSY);
 	}
 
+	/* Zero out the MFI frame */
+	context = cm->cm_frame->header.context;
+	bzero(cm->cm_frame,sizeof (union mfi_frame));
+	cm->cm_frame->header.context = context;
+
 	abort = &cm->cm_frame->abort;
 	abort->header.cmd = MFI_CMD_ABORT;
 	abort->header.flags = 0;
+	abort->header.scsi_status = 0;
 	abort->abort_context = cm_abort->cm_frame->header.context;
 	abort->abort_mfi_addr_lo = cm_abort->cm_frame_busaddr;
 	abort->abort_mfi_addr_hi = 0;
@@ -1683,15 +2499,22 @@
 	struct mfi_command *cm;
 	struct mfi_io_frame *io;
 	int error;
+	uint32_t context = 0;
 
 	if ((cm = mfi_dequeue_free(sc)) == NULL)
 		return (EBUSY);
 
+	/* Zero out the MFI frame */
+	context = cm->cm_frame->header.context;
+	bzero(cm->cm_frame,sizeof (union mfi_frame));
+	cm->cm_frame->header.context = context;
+
 	io = &cm->cm_frame->io;
 	io->header.cmd = MFI_CMD_LD_WRITE;
 	io->header.target_id = id;
 	io->header.timeout = 0;
 	io->header.flags = 0;
+	io->header.scsi_status = 0;
 	io->header.sense_len = MFI_SENSE_LEN;
 	io->header.data_len = (len + MFI_SECTOR_LEN - 1) / MFI_SECTOR_LEN;
 	io->sense_addr_lo = cm->cm_sense_busaddr;
@@ -1713,8 +2536,54 @@
 	return (error);
 }
 
+int
+mfi_dump_syspd_blocks(struct mfi_softc *sc, int id, uint64_t lba, void *virt, int len)
+{
+	struct mfi_command *cm;
+	struct mfi_pass_frame *pass;
+	int error;
+	int blkcount = 0;
+
+	if ((cm = mfi_dequeue_free(sc)) == NULL)
+		return (EBUSY);
+
+	pass = &cm->cm_frame->pass;
+	bzero(pass->cdb,16);
+	pass->header.cmd = MFI_CMD_PD_SCSI_IO;
+	pass->cdb[0] = SCSI_WRITE;
+	pass->cdb[2] = (lba & 0xff000000) >> 24;
+	pass->cdb[3] = (lba & 0x00ff0000) >> 16;
+	pass->cdb[4] = (lba & 0x0000ff00) >> 8;
+	pass->cdb[5] = (lba & 0x000000ff);
+	blkcount = (len + MFI_SECTOR_LEN - 1) / MFI_SECTOR_LEN;
+	pass->cdb[7] = (blkcount & 0xff00) >> 8;
+	pass->cdb[8] = (blkcount & 0x00ff);
+	pass->header.target_id = id;
+	pass->header.timeout = 0;
+	pass->header.flags = 0;
+	pass->header.scsi_status = 0;
+	pass->header.sense_len = MFI_SENSE_LEN;
+	pass->header.data_len = len;
+	pass->header.cdb_len = 10;
+	pass->sense_addr_lo = cm->cm_sense_busaddr;
+	pass->sense_addr_hi = 0;
+	cm->cm_data = virt;
+	cm->cm_len = len;
+	cm->cm_sg = &pass->sgl;
+	cm->cm_total_frame_size = MFI_PASS_FRAME_SIZE;
+	cm->cm_flags = MFI_CMD_POLLED | MFI_CMD_DATAOUT;
+
+	error = mfi_mapcmd(sc, cm);
+	bus_dmamap_sync(sc->mfi_buffer_dmat, cm->cm_dmamap,
+	    BUS_DMASYNC_POSTWRITE);
+	bus_dmamap_unload(sc->mfi_buffer_dmat, cm->cm_dmamap);
+	mfi_release_command(cm);
+
+	return (error);
+}
+
 static int
-mfi_open(struct cdev *dev, int flags, int fmt, struct thread *td)
+mfi_open(struct cdev *dev, int flags, int fmt, d_thread_t *td)
 {
 	struct mfi_softc *sc;
 	int error;
@@ -1734,7 +2603,7 @@
 }
 
 static int
-mfi_close(struct cdev *dev, int flags, int fmt, struct thread *td)
+mfi_close(struct cdev *dev, int flags, int fmt, d_thread_t *td)
 {
 	struct mfi_softc *sc;
 	struct mfi_aen *mfi_aen_entry, *tmp;
@@ -1784,6 +2653,9 @@
 {
 	struct mfi_disk *ld, *ld2;
 	int error;
+	struct mfi_system_pd *syspd = NULL;
+	uint16_t syspd_id;
+	uint16_t *mbox;
 
 	mtx_assert(&sc->mfi_io_lock, MA_OWNED);
 	error = 0;
@@ -1812,6 +2684,22 @@
 			}
 		}
 		break;
+	case MFI_DCMD_PD_STATE_SET:
+		mbox = (uint16_t *) cm->cm_frame->dcmd.mbox;
+		syspd_id = mbox[0];
+		if (mbox[2] == MFI_PD_STATE_UNCONFIGURED_GOOD) {
+			if (!TAILQ_EMPTY(&sc->mfi_syspd_tqh)) {
+			    TAILQ_FOREACH(syspd,&sc->mfi_syspd_tqh,pd_link) {
+				if(syspd->pd_id == syspd_id)
+					break;
+			   }
+			}
+		}
+		else
+			break;
+		if(syspd)
+			error = mfi_syspd_disable(syspd);
+		break;
 	default:
 		break;
 	}
@@ -1823,6 +2711,9 @@
 mfi_check_command_post(struct mfi_softc *sc, struct mfi_command *cm)
 {
 	struct mfi_disk *ld, *ldn;
+	struct mfi_system_pd *syspd = NULL;
+	uint16_t syspd_id;
+	uint16_t *mbox;
 
 	switch (cm->cm_frame->dcmd.opcode) {
 	case MFI_DCMD_LD_DELETE:
@@ -1860,104 +2751,86 @@
 	case MFI_DCMD_CFG_FOREIGN_IMPORT:
 		mfi_ldprobe(sc);
 		break;
+	case MFI_DCMD_PD_STATE_SET:
+		mbox = (uint16_t *) cm->cm_frame->dcmd.mbox;
+		syspd_id = mbox[0];
+		if (mbox[2] == MFI_PD_STATE_UNCONFIGURED_GOOD) {
+			if (!TAILQ_EMPTY(&sc->mfi_syspd_tqh)) {
+			    TAILQ_FOREACH(syspd,&sc->mfi_syspd_tqh,pd_link) {
+				if(syspd->pd_id == syspd_id)
+					break;
+			   }
+			}
+		}
+		else
+			break;
+		/* If the transition fails then enable the syspd again */
+		if(syspd && cm->cm_frame->header.cmd_status != MFI_STAT_OK)
+			mfi_syspd_enable(syspd);
+		break;
 	}
 }
 
-static int
-mfi_user_command(struct mfi_softc *sc, struct mfi_ioc_passthru *ioc)
+static int mfi_check_for_sscd(struct mfi_softc *sc, struct mfi_command *cm)
 {
-	struct mfi_command *cm;
-	struct mfi_dcmd_frame *dcmd;
-	void *ioc_buf = NULL;
-	uint32_t context;
-	int error = 0, locked;
-
+	struct mfi_config_data *conf_data=(struct mfi_config_data *)cm->cm_data;
+	struct mfi_command *ld_cm = NULL;
+	struct mfi_ld_info *ld_info = NULL;
+	int error = 0;
 
-	if (ioc->buf_size > 0) {
-		ioc_buf = malloc(ioc->buf_size, M_MFIBUF, M_WAITOK);
-		if (ioc_buf == NULL) {
-			return (ENOMEM);
-		}
-		error = copyin(ioc->buf, ioc_buf, ioc->buf_size);
-		if (error) {
-			device_printf(sc->mfi_dev, "failed to copyin\n");
-			free(ioc_buf, M_MFIBUF);
-			return (error);
+	if ((cm->cm_frame->dcmd.opcode == MFI_DCMD_CFG_ADD) &&
+	    (conf_data->ld[0].params.isSSCD == 1)){
+		error = 1;
+	}else if (cm->cm_frame->dcmd.opcode == MFI_DCMD_LD_DELETE){
+		error = mfi_dcmd_command (sc, &ld_cm, MFI_DCMD_LD_GET_INFO,
+					  (void **)&ld_info, sizeof(*ld_info));
+		if (error){
+			device_printf(sc->mfi_dev,"Failed to allocate"
+					"MFI_DCMD_LD_GET_INFO %d", error);
+			if (ld_info)
+				free(ld_info, M_MFIBUF);	
+			return 0;
+		}
+		ld_cm->cm_flags = MFI_CMD_DATAIN;
+		ld_cm->cm_frame->dcmd.mbox[0]= cm->cm_frame->dcmd.mbox[0];
+		ld_cm->cm_frame->header.target_id = cm->cm_frame->dcmd.mbox[0];
+		if (mfi_wait_command(sc, ld_cm) != 0){
+			device_printf(sc->mfi_dev,"failed to get log drv\n");
+			mfi_release_command(ld_cm);
+			free(ld_info, M_MFIBUF);
+			return 0;
 		}
-	}
-
-	locked = mfi_config_lock(sc, ioc->ioc_frame.opcode);
-
-	mtx_lock(&sc->mfi_io_lock);
-	while ((cm = mfi_dequeue_free(sc)) == NULL)
-		msleep(mfi_user_command, &sc->mfi_io_lock, 0, "mfiioc", hz);
-
-	/* Save context for later */
-	context = cm->cm_frame->header.context;
-
-	dcmd = &cm->cm_frame->dcmd;
-	bcopy(&ioc->ioc_frame, dcmd, sizeof(struct mfi_dcmd_frame));
 
-	cm->cm_sg = &dcmd->sgl;
-	cm->cm_total_frame_size = MFI_DCMD_FRAME_SIZE;
-	cm->cm_data = ioc_buf;
-	cm->cm_len = ioc->buf_size;
-
-	/* restore context */
-	cm->cm_frame->header.context = context;
+		if(ld_cm->cm_frame->header.cmd_status != MFI_STAT_OK){
+			free(ld_info, M_MFIBUF);
+			mfi_release_command(ld_cm);
+			return 0;
+		}
+		else
+			ld_info = (struct mfi_ld_info *)ld_cm->cm_private;
 
-	/* Cheat since we don't know if we're writing or reading */
-	cm->cm_flags = MFI_CMD_DATAIN | MFI_CMD_DATAOUT;
+		if (ld_info->ld_config.params.isSSCD == 1)
+			error = 1;
 
-	error = mfi_check_command_pre(sc, cm);
-	if (error)
-		goto out;
+		mfi_release_command(ld_cm);
+		free(ld_info, M_MFIBUF);
 
-	error = mfi_wait_command(sc, cm);
-	if (error) {
-		device_printf(sc->mfi_dev, "ioctl failed %d\n", error);
-		goto out;
 	}
-	bcopy(dcmd, &ioc->ioc_frame, sizeof(struct mfi_dcmd_frame));
-	mfi_check_command_post(sc, cm);
-out:
-	mfi_release_command(cm);
-	mtx_unlock(&sc->mfi_io_lock);
-	mfi_config_unlock(sc, locked);
-	if (ioc->buf_size > 0)
-		error = copyout(ioc_buf, ioc->buf, ioc->buf_size);
-	if (ioc_buf)
-		free(ioc_buf, M_MFIBUF);
-	return (error);
+	return error;
 }
 
-#ifdef __amd64__
-#define	PTRIN(p)		((void *)(uintptr_t)(p))
-#else
-#define	PTRIN(p)		(p)
-#endif
-
 static int
-mfi_ioctl(struct cdev *dev, u_long cmd, caddr_t arg, int flag, struct thread *td)
+mfi_ioctl(struct cdev *dev, u_long cmd, caddr_t arg, int flag, d_thread_t *td)
 {
 	struct mfi_softc *sc;
 	union mfi_statrequest *ms;
 	struct mfi_ioc_packet *ioc;
-#ifdef __amd64__
-	struct mfi_ioc_packet32 *ioc32;
-#endif
 	struct mfi_ioc_aen *aen;
 	struct mfi_command *cm = NULL;
-	uint32_t context;
-	union mfi_sense_ptr sense_ptr;
-	uint8_t *data = NULL, *temp, *addr;
-	size_t len;
+	uint32_t context = 0;
+	uint32_t *sense_ptr;
+	uint8_t *data = NULL, *temp,skip_pre_post=0;
 	int i;
-	struct mfi_ioc_passthru *iop = (struct mfi_ioc_passthru *)arg;
-#ifdef __amd64__
-	struct mfi_ioc_passthru32 *iop32 = (struct mfi_ioc_passthru32 *)arg;
-	struct mfi_ioc_passthru iop_swab;
-#endif
 	int error, locked;
 
 	sc = dev->si_drv1;
@@ -2004,9 +2877,6 @@
 		break;
 	}
 	case MFI_CMD:
-#ifdef __amd64__
-	case MFI_CMD32:
-#endif
 		{
 		devclass_t devclass;
 		ioc = (struct mfi_ioc_packet *)arg;
@@ -2032,9 +2902,10 @@
 		context = cm->cm_frame->header.context;
 
 		bcopy(ioc->mfi_frame.raw, cm->cm_frame,
-		    2 * MFI_DCMD_FRAME_SIZE);  /* this isn't quite right */
-		cm->cm_total_frame_size = (sizeof(union mfi_sgl)
-		    * ioc->mfi_sge_count) + ioc->mfi_sgl_off;
+		      2 * MFI_DCMD_FRAME_SIZE);  /* this isn't quite right */
+		cm->cm_total_frame_size = (sizeof(union mfi_sgl) * ioc->mfi_sge_count) + ioc->mfi_sgl_off;
+		cm->cm_frame->header.scsi_status = 0;
+		cm->cm_frame->header.pad0 = 0;
 		if (ioc->mfi_sge_count) {
 			cm->cm_sg =
 			    (union mfi_sgl *)&cm->cm_frame->bytes[ioc->mfi_sgl_off];
@@ -2048,23 +2919,7 @@
 		if (cm->cm_flags == 0)
 			cm->cm_flags |= MFI_CMD_DATAIN | MFI_CMD_DATAOUT;
 		cm->cm_len = cm->cm_frame->header.data_len;
-		if (cm->cm_frame->header.cmd == MFI_CMD_STP) {
-#ifdef __amd64__
-			if (cmd == MFI_CMD) {
-#endif
-				/* Native */
-				cm->cm_stp_len = ioc->mfi_sgl[0].iov_len;
-#ifdef __amd64__
-			} else {
-				/* 32bit on 64bit */
-				ioc32 = (struct mfi_ioc_packet32 *)ioc;
-				cm->cm_stp_len = ioc32->mfi_sgl[0].iov_len;
-			}
-#endif
-			cm->cm_len += cm->cm_stp_len;
-		}
-		if (cm->cm_len &&
-		    (cm->cm_flags & (MFI_CMD_DATAIN | MFI_CMD_DATAOUT))) {
+		if (cm->cm_len && (cm->cm_flags & (MFI_CMD_DATAIN | MFI_CMD_DATAOUT))) {
 			cm->cm_data = data = malloc(cm->cm_len, M_MFIBUF,
 			    M_WAITOK | M_ZERO);
 			if (cm->cm_data == NULL) {
@@ -2079,30 +2934,17 @@
 		cm->cm_frame->header.context = context;
 
 		temp = data;
-		if ((cm->cm_flags & MFI_CMD_DATAOUT) ||
-		    (cm->cm_frame->header.cmd == MFI_CMD_STP)) {
+		if (cm->cm_flags & MFI_CMD_DATAOUT) {
 			for (i = 0; i < ioc->mfi_sge_count; i++) {
-#ifdef __amd64__
-				if (cmd == MFI_CMD) {
-#endif
-					/* Native */
-					addr = ioc->mfi_sgl[i].iov_base;
-					len = ioc->mfi_sgl[i].iov_len;
-#ifdef __amd64__
-				} else {
-					/* 32bit on 64bit */
-					ioc32 = (struct mfi_ioc_packet32 *)ioc;
-					addr = PTRIN(ioc32->mfi_sgl[i].iov_base);
-					len = ioc32->mfi_sgl[i].iov_len;
-				}
-#endif
-				error = copyin(addr, temp, len);
+				error = copyin(ioc->mfi_sgl[i].iov_base,
+				       temp,
+				       ioc->mfi_sgl[i].iov_len);
 				if (error != 0) {
 					device_printf(sc->mfi_dev,
 					    "Copy in failed\n");
 					goto out;
 				}
-				temp = &temp[len];
+				temp = &temp[ioc->mfi_sgl[i].iov_len];
 			}
 		}
 
@@ -2113,66 +2955,47 @@
 			cm->cm_frame->pass.sense_addr_lo = cm->cm_sense_busaddr;
 			cm->cm_frame->pass.sense_addr_hi = 0;
 		}
-
+		
 		mtx_lock(&sc->mfi_io_lock);
-		error = mfi_check_command_pre(sc, cm);
-		if (error) {
-			mtx_unlock(&sc->mfi_io_lock);
-			goto out;
+		skip_pre_post = mfi_check_for_sscd (sc, cm);
+		if (!skip_pre_post){
+			error = mfi_check_command_pre(sc, cm);
+			if (error) {
+				mtx_unlock(&sc->mfi_io_lock);
+				goto out;
+			}
 		}
-
 		if ((error = mfi_wait_command(sc, cm)) != 0) {
 			device_printf(sc->mfi_dev,
 			    "Controller polled failed\n");
 			mtx_unlock(&sc->mfi_io_lock);
 			goto out;
 		}
-
-		mfi_check_command_post(sc, cm);
+		if (!skip_pre_post){
+			mfi_check_command_post(sc, cm);
+		}
 		mtx_unlock(&sc->mfi_io_lock);
 
 		temp = data;
-		if ((cm->cm_flags & MFI_CMD_DATAIN) ||
-		    (cm->cm_frame->header.cmd == MFI_CMD_STP)) {
+		if (cm->cm_flags & MFI_CMD_DATAIN) {
 			for (i = 0; i < ioc->mfi_sge_count; i++) {
-#ifdef __amd64__
-				if (cmd == MFI_CMD) {
-#endif
-					/* Native */
-					addr = ioc->mfi_sgl[i].iov_base;
-					len = ioc->mfi_sgl[i].iov_len;
-#ifdef __amd64__
-				} else {
-					/* 32bit on 64bit */
-					ioc32 = (struct mfi_ioc_packet32 *)ioc;
-					addr = PTRIN(ioc32->mfi_sgl[i].iov_base);
-					len = ioc32->mfi_sgl[i].iov_len;
-				}
-#endif
-				error = copyout(temp, addr, len);
+				error = copyout(temp,
+					ioc->mfi_sgl[i].iov_base,
+					ioc->mfi_sgl[i].iov_len);
 				if (error != 0) {
 					device_printf(sc->mfi_dev,
 					    "Copy out failed\n");
 					goto out;
 				}
-				temp = &temp[len];
+				temp = &temp[ioc->mfi_sgl[i].iov_len];
 			}
 		}
 
 		if (ioc->mfi_sense_len) {
-			/* get user-space sense ptr then copy out sense */
-			bcopy(&ioc->mfi_frame.raw[ioc->mfi_sense_off],
-			    &sense_ptr.sense_ptr_data[0],
-			    sizeof(sense_ptr.sense_ptr_data));
-#ifdef __amd64__
-			if (cmd != MFI_CMD) {
-				/*
-				 * not 64bit native so zero out any address
-				 * over 32bit */
-				sense_ptr.addr.high = 0;
-			}
-#endif
-			error = copyout(cm->cm_sense, sense_ptr.user_space,
+			/* copy out sense */
+			sense_ptr = (int *) &((struct mfi_ioc_packet*)arg)
+			    ->mfi_frame.raw[ioc->mfi_sense_off];
+			error = copyout (cm->cm_sense,(void *)(uint64_t)*sense_ptr,
 			    ioc->mfi_sense_len);
 			if (error != 0) {
 				device_printf(sc->mfi_dev,
@@ -2242,21 +3065,6 @@
 			    cmd, arg, flag, td));
 			break;
 		}
-#ifdef __amd64__
-	case MFIIO_PASSTHRU32:
-		iop_swab.ioc_frame	= iop32->ioc_frame;
-		iop_swab.buf_size	= iop32->buf_size;
-		iop_swab.buf		= PTRIN(iop32->buf);
-		iop			= &iop_swab;
-		/* FALLTHROUGH */
-#endif
-	case MFIIO_PASSTHRU:
-		error = mfi_user_command(sc, iop);
-#ifdef __amd64__
-		if (cmd == MFIIO_PASSTHRU32)
-			iop32->ioc_frame = iop_swab.ioc_frame;
-#endif
-		break;
 	default:
 		device_printf(sc->mfi_dev, "IOCTL 0x%lx not handled\n", cmd);
 		error = ENOENT;
@@ -2267,16 +3075,17 @@
 }
 
 static int
-mfi_linux_ioctl_int(struct cdev *dev, u_long cmd, caddr_t arg, int flag, struct thread *td)
+mfi_linux_ioctl_int(struct cdev *dev, u_long cmd, caddr_t arg, int flag, d_thread_t *td)
 {
 	struct mfi_softc *sc;
 	struct mfi_linux_ioc_packet l_ioc;
 	struct mfi_linux_ioc_aen l_aen;
 	struct mfi_command *cm = NULL;
 	struct mfi_aen *mfi_aen_entry;
-	union mfi_sense_ptr sense_ptr;
-	uint32_t context;
+	uint8_t *sense_ptr;
+	uint32_t context = 0;
 	uint8_t *data = NULL, *temp;
+	void *temp_convert;
 	int i;
 	int error, locked;
 
@@ -2308,8 +3117,9 @@
 
 		bcopy(l_ioc.lioc_frame.raw, cm->cm_frame,
 		      2 * MFI_DCMD_FRAME_SIZE);	/* this isn't quite right */
-		cm->cm_total_frame_size = (sizeof(union mfi_sgl)
-		      * l_ioc.lioc_sge_count) + l_ioc.lioc_sgl_off;
+		cm->cm_total_frame_size = (sizeof(union mfi_sgl) * l_ioc.lioc_sge_count) + l_ioc.lioc_sgl_off;
+		cm->cm_frame->header.scsi_status = 0;
+		cm->cm_frame->header.pad0 = 0;
 		if (l_ioc.lioc_sge_count)
 			cm->cm_sg =
 			    (union mfi_sgl *)&cm->cm_frame->bytes[l_ioc.lioc_sgl_off];
@@ -2319,8 +3129,7 @@
 		if (cm->cm_frame->header.flags & MFI_FRAME_DATAOUT)
 			cm->cm_flags |= MFI_CMD_DATAOUT;
 		cm->cm_len = cm->cm_frame->header.data_len;
-		if (cm->cm_len &&
-		      (cm->cm_flags & (MFI_CMD_DATAIN | MFI_CMD_DATAOUT))) {
+		if (cm->cm_flags & (MFI_CMD_DATAIN | MFI_CMD_DATAOUT)) {
 			cm->cm_data = data = malloc(cm->cm_len, M_MFIBUF,
 			    M_WAITOK | M_ZERO);
 			if (cm->cm_data == NULL) {
@@ -2337,7 +3146,9 @@
 		temp = data;
 		if (cm->cm_flags & MFI_CMD_DATAOUT) {
 			for (i = 0; i < l_ioc.lioc_sge_count; i++) {
-				error = copyin(PTRIN(l_ioc.lioc_sgl[i].iov_base),
+				temp_convert =
+				    (void *)(uintptr_t)l_ioc.lioc_sgl[i].iov_base;
+				error = copyin(temp_convert,
 				       temp,
 				       l_ioc.lioc_sgl[i].iov_len);
 				if (error != 0) {
@@ -2356,7 +3167,7 @@
 			cm->cm_frame->pass.sense_addr_lo = cm->cm_sense_busaddr;
 			cm->cm_frame->pass.sense_addr_hi = 0;
 		}
-
+		
 		mtx_lock(&sc->mfi_io_lock);
 		error = mfi_check_command_pre(sc, cm);
 		if (error) {
@@ -2377,8 +3188,10 @@
 		temp = data;
 		if (cm->cm_flags & MFI_CMD_DATAIN) {
 			for (i = 0; i < l_ioc.lioc_sge_count; i++) {
+				temp_convert =
+				    (void *)(uintptr_t)l_ioc.lioc_sgl[i].iov_base;
 				error = copyout(temp,
-					PTRIN(l_ioc.lioc_sgl[i].iov_base),
+					temp_convert,
 					l_ioc.lioc_sgl[i].iov_len);
 				if (error != 0) {
 					device_printf(sc->mfi_dev,
@@ -2390,19 +3203,10 @@
 		}
 
 		if (l_ioc.lioc_sense_len) {
-			/* get user-space sense ptr then copy out sense */
-			bcopy(&((struct mfi_linux_ioc_packet*)arg)
-                            ->lioc_frame.raw[l_ioc.lioc_sense_off],
-			    &sense_ptr.sense_ptr_data[0],
-			    sizeof(sense_ptr.sense_ptr_data));
-#ifdef __amd64__
-			/*
-			 * only 32bit Linux support so zero out any
-			 * address over 32bit
-			 */
-			sense_ptr.addr.high = 0;
-#endif
-			error = copyout(cm->cm_sense, sense_ptr.user_space,
+			/* copy out sense */
+			sense_ptr = &((struct mfi_linux_ioc_packet*)arg)
+			    ->lioc_frame.raw[0];
+			error = copyout(cm->cm_sense, sense_ptr,
 			    l_ioc.lioc_sense_len);
 			if (error != 0) {
 				device_printf(sc->mfi_dev,
diff -Nur src.orig/sys/dev/mfi/mfi_cam.c src/sys/dev/mfi/mfi_cam.c
--- src.orig/sys/dev/mfi/mfi_cam.c	2012-01-03 11:26:42.000000000 +0800
+++ src/sys/dev/mfi/mfi_cam.c	2010-02-18 14:51:16.000000000 +0800
@@ -1,31 +1,37 @@
+
 /*-
- * Copyright 2007 Scott Long
- * All rights reserved.
- *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
+ *
+ *            Copyright 1994-2009 The FreeBSD Project.
+ *            All rights reserved.   
+ *                 
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
+ *    THIS SOFTWARE IS PROVIDED BY THE FREEBSD PROJECT``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FREEBSD PROJECT OR 
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY,OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY THEORY 
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * The views and conclusions contained in the software and documentation 
+ * are those of the authors and should not be interpreted as representing 
+ * official policies,either expressed or implied, of the FreeBSD Project.	
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: release/9.0.0/sys/dev/mfi/mfi_cam.c 226910 2011-10-29 22:06:53Z marius $");
+__FBSDID("$FreeBSD: src/sys/dev/mfi/mfi_cam.c,v 1.3 2007/10/12 16:52:55 scottl Exp $");
 
 #include "opt_mfi.h"
 
@@ -54,9 +60,12 @@
 #include <cam/scsi/scsi_all.h>
 #include <cam/scsi/scsi_message.h>
 
+#include <sys/bus.h>
+#include <sys/conf.h>
 #include <machine/md_var.h>
 #include <machine/bus.h>
 #include <machine/resource.h>
+#include <sys/rman.h>
 
 #include <dev/mfi/mfireg.h>
 #include <dev/mfi/mfi_ioctl.h>
@@ -92,7 +101,6 @@
 };
 DRIVER_MODULE(mfip, mfi, mfip_driver, mfip_devclass, 0, 0);
 MODULE_DEPEND(mfip, cam, 1, 1, 1);
-MODULE_DEPEND(mfip, mfi, 1, 1, 1);
 
 #define ccb_mfip_ptr sim_priv.entries[0].ptr
 
@@ -269,12 +277,18 @@
 	struct mfip_softc *sc;
 	struct mfi_pass_frame *pt;
 	struct mfi_command *cm;
+	uint32_t context = 0;
 
 	sc = ccbh->ccb_mfip_ptr;
 
 	if ((cm = mfi_dequeue_free(sc->mfi_sc)) == NULL)
 		return (NULL);
 
+	/* Zero out the MFI frame */
+	context = cm->cm_frame->header.context;
+	bzero(cm->cm_frame,sizeof(union mfi_frame));
+	cm->cm_frame->header.context = context;
+
 	pt = &cm->cm_frame->pass;
 	pt->header.cmd = MFI_CMD_PD_SCSI_IO;
 	pt->header.cmd_status = 0;
@@ -337,14 +351,14 @@
 		ccbh->status = CAM_REQ_CMP;
 		csio->scsi_status = pt->header.scsi_status;
 		if (ccbh->flags & CAM_CDB_POINTER)
-			command = csio->cdb_io.cdb_ptr[0];
+			command = ccb->csio.cdb_io.cdb_ptr[0];
 		else
-			command = csio->cdb_io.cdb_bytes[0];
+			command = ccb->csio.cdb_io.cdb_bytes[0];
 		if (command == INQUIRY) {
-			device = csio->data_ptr[0] & 0x1f;
+			device = ccb->csio.data_ptr[0] & 0x1f;
 			if ((device == T_DIRECT) || (device == T_PROCESSOR))
 				csio->data_ptr[0] =
-				     (csio->data_ptr[0] & 0xe0) | T_NODEVICE;
+				     (device & 0xe0) | T_NODEVICE;
 		}
 		break;
 	}
@@ -354,13 +368,7 @@
 
 		ccbh->status = CAM_SCSI_STATUS_ERROR | CAM_AUTOSNS_VALID;
 		csio->scsi_status = pt->header.scsi_status;
-		if (pt->header.sense_len < csio->sense_len)
-			csio->sense_resid = csio->sense_len -
-			    pt->header.sense_len;
-		else
-			csio->sense_resid = 0;
-		sense_len = min(pt->header.sense_len,
-		    sizeof(struct scsi_sense_data));
+		sense_len = min(pt->header.sense_len, sizeof(struct scsi_sense_data));
 		bzero(&csio->sense_data, sizeof(struct scsi_sense_data));
 		bcopy(&cm->cm_sense->data[0], &csio->sense_data, sense_len);
 		break;
diff -Nur src.orig/sys/dev/mfi/mfi_debug.c src/sys/dev/mfi/mfi_debug.c
--- src.orig/sys/dev/mfi/mfi_debug.c	2012-01-03 11:26:42.000000000 +0800
+++ src/sys/dev/mfi/mfi_debug.c	2010-02-18 14:51:16.000000000 +0800
@@ -1,31 +1,37 @@
+
 /*-
- * Copyright (c) 2006 IronPort Systems
- * All rights reserved.
- *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
+ *
+ *            Copyright 1994-2009 The FreeBSD Project.
+ *            All rights reserved.   
+ *                 
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
+ *    THIS SOFTWARE IS PROVIDED BY THE FREEBSD PROJECT``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FREEBSD PROJECT OR 
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY,OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY THEORY 
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * The views and conclusions contained in the software and documentation 
+ * are those of the authors and should not be interpreted as representing 
+ * official policies,either expressed or implied, of the FreeBSD Project.	
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: release/9.0.0/sys/dev/mfi/mfi_debug.c 163398 2006-10-16 04:18:38Z scottl $");
+__FBSDID("$FreeBSD: src/sys/dev/mfi/mfi_debug.c,v 1.3 2006/10/16 04:18:38 scottl Exp $");
 
 #include "opt_mfi.h"
 
diff -Nur src.orig/sys/dev/mfi/mfi_disk.c src/sys/dev/mfi/mfi_disk.c
--- src.orig/sys/dev/mfi/mfi_disk.c	2012-01-03 11:26:42.000000000 +0800
+++ src/sys/dev/mfi/mfi_disk.c	2010-02-18 14:51:16.000000000 +0800
@@ -1,31 +1,37 @@
 /*-
- * Copyright (c) 2006 IronPort Systems
- * All rights reserved.
- *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
+ *
+ *            Copyright 1994-2009 The FreeBSD Project.
+ *            All rights reserved.   
+ *                 
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
+ *    THIS SOFTWARE IS PROVIDED BY THE FREEBSD PROJECT``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FREEBSD PROJECT OR 
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY,OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY THEORY 
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * The views and conclusions contained in the software and documentation 
+ * are those of the authors and should not be interpreted as representing 
+ * official policies,either expressed or implied, of the FreeBSD Project.	
  */
 
+
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: release/9.0.0/sys/dev/mfi/mfi_disk.c 185035 2008-11-17 23:30:19Z jhb $");
+__FBSDID("$FreeBSD: src/sys/dev/mfi/mfi_disk.c,v 1.7 2007/08/13 19:29:17 jhb Exp $");
 
 #include "opt_mfi.h"
 
@@ -136,8 +142,7 @@
 
 	sc->ld_disk = disk_alloc();
 	sc->ld_disk->d_drv1 = sc;
-	sc->ld_disk->d_maxsize = min(sc->ld_controller->mfi_max_io * secsize,
-	    (sc->ld_controller->mfi_max_sge - 1) * PAGE_SIZE);
+	sc->ld_disk->d_maxsize = sc->ld_controller->mfi_max_io * secsize;
 	sc->ld_disk->d_name = "mfid";
 	sc->ld_disk->d_open = mfi_disk_open;
 	sc->ld_disk->d_close = mfi_disk_close;
@@ -223,7 +228,7 @@
 	if (sc->ld_flags & MFI_DISK_FLAGS_OPEN) {
 		if (sc->ld_controller->mfi_delete_busy_volumes)
 			return (0);
-		device_printf(sc->ld_dev, "Unable to delete busy device\n");
+		device_printf(sc->ld_dev, "Unable to delete busy ld device\n");
 		return (EBUSY);
 	}
 	sc->ld_flags |= MFI_DISK_FLAGS_DISABLED;
@@ -256,6 +261,8 @@
 
 	controller = sc->ld_controller;
 	bio->bio_driver1 = (void *)(uintptr_t)sc->ld_id;
+	/* Mark it as LD IO */
+	bio->bio_driver2 = (void *)MFI_LD_IO;
 	mtx_lock(&controller->mfi_io_lock);
 	mfi_enqueue_bio(controller, bio);
 	mfi_startio(controller);
diff -Nur src.orig/sys/dev/mfi/mfi_ioctl.h src/sys/dev/mfi/mfi_ioctl.h
--- src.orig/sys/dev/mfi/mfi_ioctl.h	2012-01-03 11:26:42.000000000 +0800
+++ src/sys/dev/mfi/mfi_ioctl.h	2012-03-10 06:51:09.000000000 +0800
@@ -1,33 +1,39 @@
+
 /*-
- * Copyright (c) 2006 IronPort Systems
- * All rights reserved.
- *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
+ *
+ *            Copyright 1994-2009 The FreeBSD Project.
+ *            All rights reserved.   
+ *                 
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
+ *    THIS SOFTWARE IS PROVIDED BY THE FREEBSD PROJECT``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FREEBSD PROJECT OR 
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY,OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY THEORY 
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * The views and conclusions contained in the software and documentation 
+ * are those of the authors and should not be interpreted as representing 
+ * official policies,either expressed or implied, of the FreeBSD Project.	
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: release/9.0.0/sys/dev/mfi/mfi_ioctl.h 196200 2009-08-13 23:18:45Z scottl $");
+__FBSDID("$FreeBSD: src/sys/dev/mfi/mfi_ioctl.h,v 1.5 2007/05/10 15:33:41 scottl Exp $");
 
-#include <dev/mfi/mfireg.h>
+#include "mfireg.h"
 
 #if defined(__amd64__) /* Assume amd64 wants 32 bit Linux */
 struct iovec32 {
diff -Nur src.orig/sys/dev/mfi/mfi_linux.c src/sys/dev/mfi/mfi_linux.c
--- src.orig/sys/dev/mfi/mfi_linux.c	2012-01-03 11:26:42.000000000 +0800
+++ src/sys/dev/mfi/mfi_linux.c	2012-03-08 08:30:09.000000000 +0800
@@ -1,35 +1,39 @@
 /*-
- * Copyright (c) 2006 IronPort Systems
- * All rights reserved.
- *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
+ *
+ *            Copyright 1994-2009 The FreeBSD Project.
+ *            All rights reserved.   
+ *                 
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
+ *    THIS SOFTWARE IS PROVIDED BY THE FREEBSD PROJECT``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FREEBSD PROJECT OR 
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY,OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY THEORY 
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * The views and conclusions contained in the software and documentation 
+ * are those of the authors and should not be interpreted as representing 
+ * official policies,either expressed or implied, of the FreeBSD Project.	
  */
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: release/9.0.0/sys/dev/mfi/mfi_linux.c 224778 2011-08-11 12:30:23Z rwatson $");
+__FBSDID("$FreeBSD: src/sys/dev/mfi/mfi_linux.c,v 1.2 2006/11/14 16:48:00 ambrisko Exp $");
 
 #include <sys/param.h>
 #include <sys/systm.h>
-#include <sys/capability.h>
 #include <sys/conf.h>
 #include <sys/kernel.h>
 #include <sys/module.h>
@@ -81,11 +85,15 @@
 MODULE_DEPEND(mfi, linux, 1, 1, 1);
 
 static int
-mfi_linux_ioctl(struct thread *p, struct linux_ioctl_args *args)
+mfi_linux_ioctl(d_thread_t *p, struct linux_ioctl_args *args)
 {
+#define CAP_IOCTL			0x0004000000000000ULL
+
 	struct file *fp;
 	int error;
 	u_long cmd = args->cmd;
+	if ((error = fget(p, args->fd, CAP_IOCTL, &fp)) != 0)
+		return (error);
 
 	switch (cmd) {
 	case MFI_LINUX_CMD:
@@ -96,8 +104,6 @@
 		break;
 	}
 
-	if ((error = fget(p, args->fd, CAP_IOCTL, &fp)) != 0)
-		return (error);
 	error = fo_ioctl(fp, cmd, (caddr_t)args->arg, p->td_ucred, p);
 	fdrop(fp, p);
 	return (error);
diff -Nur src.orig/sys/dev/mfi/mfi_pci.c src/sys/dev/mfi/mfi_pci.c
--- src.orig/sys/dev/mfi/mfi_pci.c	2012-01-03 11:26:42.000000000 +0800
+++ src/sys/dev/mfi/mfi_pci.c	2010-02-18 14:51:16.000000000 +0800
@@ -1,57 +1,38 @@
-/*-
- * Copyright (c) 2006 IronPort Systems
- * All rights reserved.
- *
+
+ /*-
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
  *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-/*-
- * Copyright (c) 2007 LSI Corp.
- * Copyright (c) 2007 Rajesh Prabhakaran.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
+ *            Copyright 1994-2009 The FreeBSD Project.
+ *            All rights reserved.   
+ *                 
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
+ *    THIS SOFTWARE IS PROVIDED BY THE FREEBSD PROJECT``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FREEBSD PROJECT OR 
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY,OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY THEORY 
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * The views and conclusions contained in the software and documentation 
+ * are those of the authors and should not be interpreted as representing 
+ * official policies,either expressed or implied, of the FreeBSD Project.	
  */
 
+
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: release/9.0.0/sys/dev/mfi/mfi_pci.c 204590 2010-03-02 17:34:11Z kib $");
+__FBSDID("$FreeBSD: src/sys/dev/mfi/mfi_pci.c,v 1.10 2007/12/19 17:23:47 ambrisko Exp $");
 
 /* PCI/PCI-X/PCIe bus interface for the LSI MegaSAS controllers */
 
@@ -105,7 +86,6 @@
 
 static devclass_t	mfi_devclass;
 DRIVER_MODULE(mfi, pci, mfi_pci_driver, mfi_devclass, 0, 0);
-MODULE_VERSION(mfi, 1);
 
 struct mfi_ident {
 	uint16_t	vendor;
@@ -115,21 +95,23 @@
 	int		flags;
 	const char	*desc;
 } mfi_identifiers[] = {
+	{0x1000, 0x0411, 0xffff, 0xffff, MFI_FLAGS_1064R, "LSI MegaSAS 1064R"}, /* Brocton IOP */
+	{0x1000, 0x0413, 0xffff, 0xffff, MFI_FLAGS_1064R, "LSI MegaSAS 1064R"}, /* Verde ZCR */
+	{0x1028, 0x0015, 0xffff, 0xffff, MFI_FLAGS_1064R, "Dell PERC 5/i"},
 	{0x1000, 0x0060, 0x1028, 0xffff, MFI_FLAGS_1078,  "Dell PERC 6"},
 	{0x1000, 0x0060, 0xffff, 0xffff, MFI_FLAGS_1078,  "LSI MegaSAS 1078"},
-	{0x1000, 0x0078, 0xffff, 0xffff, MFI_FLAGS_GEN2,  "LSI MegaSAS Gen2"},
 	{0x1000, 0x0079, 0x1028, 0x1f15, MFI_FLAGS_GEN2,  "Dell PERC H800 Adapter"},
 	{0x1000, 0x0079, 0x1028, 0x1f16, MFI_FLAGS_GEN2,  "Dell PERC H700 Adapter"},
 	{0x1000, 0x0079, 0x1028, 0x1f17, MFI_FLAGS_GEN2,  "Dell PERC H700 Integrated"},
 	{0x1000, 0x0079, 0x1028, 0x1f18, MFI_FLAGS_GEN2,  "Dell PERC H700 Modular"},
 	{0x1000, 0x0079, 0x1028, 0x1f19, MFI_FLAGS_GEN2,  "Dell PERC H700"},
+	{0x1000, 0x0079, 0x1028, 0x1f1a, MFI_FLAGS_GEN2,  "Dell PERC H800 Proto Adapter"},
 	{0x1000, 0x0079, 0x1028, 0x1f1b, MFI_FLAGS_GEN2,  "Dell PERC H800"},
-	{0x1000, 0x0079, 0x1028, 0xffff, MFI_FLAGS_GEN2,  "Dell PERC Gen2"},
+	{0x1000, 0x0078, 0xffff, 0xffff, MFI_FLAGS_GEN2,  "LSI MegaSAS Gen2"},
 	{0x1000, 0x0079, 0xffff, 0xffff, MFI_FLAGS_GEN2,  "LSI MegaSAS Gen2"},
 	{0x1000, 0x007c, 0xffff, 0xffff, MFI_FLAGS_1078,  "LSI MegaSAS 1078"},
-	{0x1000, 0x0411, 0xffff, 0xffff, MFI_FLAGS_1064R, "LSI MegaSAS 1064R"}, /* Brocton IOP */
-	{0x1000, 0x0413, 0xffff, 0xffff, MFI_FLAGS_1064R, "LSI MegaSAS 1064R"}, /* Verde ZCR */
-	{0x1028, 0x0015, 0xffff, 0xffff, MFI_FLAGS_1064R, "Dell PERC 5/i"},
+	{0x1000, 0x0071, 0xffff, 0xffff, MFI_FLAGS_SKINNY, "Drake Skinny"},
+	{0x1000, 0x0073, 0xffff, 0xffff, MFI_FLAGS_SKINNY, "Drake Skinny"},
 	{0, 0, 0, 0, 0, NULL}
 };
 
@@ -196,8 +178,10 @@
 	    (sc->mfi_flags & MFI_FLAGS_1078)) {
 		/* 1068/1078: Memory mapped BAR is at offset 0x10 */
 		sc->mfi_regs_rid = PCIR_BAR(0);
-	} else if (sc->mfi_flags & MFI_FLAGS_GEN2) {
-		/* GEN2: Memory mapped BAR is at offset 0x14 */
+	}
+	else if ((sc->mfi_flags & MFI_FLAGS_GEN2) ||
+		 (sc->mfi_flags & MFI_FLAGS_SKINNY)) {
+		/* Gen2/Skinny: Memory mapped BAR is at offset 0x14 */
 		sc->mfi_regs_rid = PCIR_BAR(1);
 	}
 	if ((sc->mfi_regs_resource = bus_alloc_resource_any(sc->mfi_dev,
@@ -241,6 +225,7 @@
 {
 	struct mfi_softc *sc;
 	struct mfi_disk *ld;
+	struct mfi_system_pd *syspd = NULL;
 	int error;
 
 	sc = device_get_softc(dev);
@@ -262,6 +247,14 @@
 			return (error);
 		}
 	}
+	if(!TAILQ_EMPTY(&sc->mfi_syspd_tqh))
+	while ((syspd = TAILQ_FIRST(&sc->mfi_syspd_tqh)) != NULL) {
+		if ((error = device_delete_child(dev,syspd->pd_dev)) != 0) {
+			sc->mfi_detaching = 0;
+			sx_xunlock(&sc->mfi_config_lock);
+			return (error);
+		}
+	}
 	sx_xunlock(&sc->mfi_config_lock);
 
 	EVENTHANDLER_DEREGISTER(shutdown_final, sc->mfi_eh);
diff -Nur src.orig/sys/dev/mfi/mfi_syspd.c src/sys/dev/mfi/mfi_syspd.c
--- src.orig/sys/dev/mfi/mfi_syspd.c	1970-01-01 08:00:00.000000000 +0800
+++ src/sys/dev/mfi/mfi_syspd.c	2010-02-18 14:51:18.000000000 +0800
@@ -0,0 +1,294 @@
+/*-
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *            Copyright 1994-2009 The FreeBSD Project.
+ *            All rights reserved.   
+ *                 
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE FREEBSD PROJECT``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FREEBSD PROJECT OR 
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY,OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY THEORY 
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * The views and conclusions contained in the software and documentation 
+ * are those of the authors and should not be interpreted as representing 
+ * official policies,either expressed or implied, of the FreeBSD Project.	
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: src/sys/dev/mfi/mfi_pddisk.c,v 1.2.2.6 2007/08/24 17:29:18 jhb Exp $");
+
+#include "opt_mfi.h"
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/selinfo.h>
+#include <sys/module.h>
+#include <sys/malloc.h>
+#include <sys/uio.h>
+
+#include <sys/bio.h>
+#include <sys/bus.h>
+#include <sys/conf.h>
+#include <sys/disk.h>
+#include <geom/geom_disk.h>
+
+#include <vm/vm.h>
+#include <vm/pmap.h>
+
+#include <machine/md_var.h>
+#include <machine/bus.h>
+#include <sys/rman.h>
+
+#include <dev/mfi/mfireg.h>
+#include <dev/mfi/mfi_ioctl.h>
+#include <dev/mfi/mfivar.h>
+
+static int	mfi_syspd_probe(device_t dev);
+static int	mfi_syspd_attach(device_t dev);
+static int	mfi_syspd_detach(device_t dev);
+
+static disk_open_t	mfi_syspd_open;
+static disk_close_t	mfi_syspd_close;
+static disk_strategy_t	mfi_syspd_strategy;
+static dumper_t		mfi_syspd_dump;
+
+static devclass_t	mfi_syspd_devclass;
+
+static device_method_t mfi_syspd_methods[] = {
+	DEVMETHOD(device_probe,		mfi_syspd_probe),
+	DEVMETHOD(device_attach,	mfi_syspd_attach),
+	DEVMETHOD(device_detach,	mfi_syspd_detach),
+	{ 0, 0 }
+};
+
+static driver_t mfi_syspd_driver = {
+	"mfisyspd",
+	mfi_syspd_methods,
+	sizeof(struct mfi_system_pd)
+};
+
+DRIVER_MODULE(mfisyspd, mfi, mfi_syspd_driver, mfi_syspd_devclass, 0, 0);
+
+static int
+mfi_syspd_probe(device_t dev)
+{
+
+	return (0);
+}
+
+static int
+mfi_syspd_attach(device_t dev)
+{
+	struct mfi_system_pd *sc;
+	struct mfi_pd_info *pd_info;
+	uint64_t sectors;
+	uint32_t secsize;
+
+	sc = device_get_softc(dev);
+	pd_info = device_get_ivars(dev);
+
+	sc->pd_dev = dev;
+	sc->pd_id = pd_info->ref.v.device_id;
+	sc->pd_unit = device_get_unit(dev);
+	sc->pd_info = pd_info;
+	sc->pd_controller = device_get_softc(device_get_parent(dev));
+	sc->pd_flags = 0;
+
+	sectors = pd_info->raw_size;
+	secsize = MFI_SECTOR_LEN;
+	mtx_lock(&sc->pd_controller->mfi_io_lock);
+	TAILQ_INSERT_TAIL(&sc->pd_controller->mfi_syspd_tqh, sc, pd_link);
+	mtx_unlock(&sc->pd_controller->mfi_io_lock);
+	device_printf(dev, "%juMB (%ju sectors) SYSPD volume\n",
+		      sectors / (1024 * 1024 / secsize), sectors);
+	sc->pd_disk = disk_alloc();
+	sc->pd_disk->d_drv1 = sc;
+	sc->pd_disk->d_maxsize = sc->pd_controller->mfi_max_io * secsize;
+	sc->pd_disk->d_name = "mfisyspd";
+	sc->pd_disk->d_open = mfi_syspd_open;
+	sc->pd_disk->d_close = mfi_syspd_close;
+	sc->pd_disk->d_strategy = mfi_syspd_strategy;
+	sc->pd_disk->d_dump = mfi_syspd_dump;
+	sc->pd_disk->d_unit = sc->pd_unit;
+	sc->pd_disk->d_sectorsize = secsize;
+	sc->pd_disk->d_mediasize = sectors * secsize;
+	if (sc->pd_disk->d_mediasize >= (1 * 1024 * 1024)) {
+		sc->pd_disk->d_fwheads = 255;
+		sc->pd_disk->d_fwsectors = 63;
+	} else {
+		sc->pd_disk->d_fwheads = 64;
+		sc->pd_disk->d_fwsectors = 32;
+	}
+	disk_create(sc->pd_disk, DISK_VERSION);
+
+	device_printf(dev, " SYSPD volume attached\n");
+	return (0);
+}
+
+static int
+mfi_syspd_detach(device_t dev)
+{
+	struct mfi_system_pd *sc;
+
+	sc = device_get_softc(dev);
+	device_printf(dev, "Detaching syspd\n");
+	mtx_lock(&sc->pd_controller->mfi_io_lock);
+	if (((sc->pd_disk->d_flags & DISKFLAG_OPEN) ||
+	    (sc->pd_flags & MFI_DISK_FLAGS_OPEN)) &&
+	    (sc->pd_controller->mfi_keep_deleted_volumes ||
+	    sc->pd_controller->mfi_detaching)) {
+		mtx_unlock(&sc->pd_controller->mfi_io_lock);
+		device_printf(dev,"Cant detach syspd\n");
+		return (EBUSY);
+	}
+	mtx_unlock(&sc->pd_controller->mfi_io_lock);
+
+	disk_destroy(sc->pd_disk);
+	mtx_lock(&sc->pd_controller->mfi_io_lock);
+	TAILQ_REMOVE(&sc->pd_controller->mfi_syspd_tqh, sc, pd_link);
+	mtx_unlock(&sc->pd_controller->mfi_io_lock);
+	free(sc->pd_info, M_MFIBUF);
+	return (0);
+}
+
+static int
+mfi_syspd_open(struct disk *dp)
+{
+	struct mfi_system_pd *sc;
+	int error;
+
+	sc = dp->d_drv1;
+	mtx_lock(&sc->pd_controller->mfi_io_lock);
+	if (sc->pd_flags & MFI_DISK_FLAGS_DISABLED)
+		error = ENXIO;
+	else {
+		sc->pd_flags |= MFI_DISK_FLAGS_OPEN;
+		error = 0;
+	}
+	mtx_unlock(&sc->pd_controller->mfi_io_lock);
+	return (error);
+}
+
+static int
+mfi_syspd_close(struct disk *dp)
+{
+	struct mfi_system_pd *sc;
+
+	sc = dp->d_drv1;
+	mtx_lock(&sc->pd_controller->mfi_io_lock);
+	sc->pd_flags &= ~MFI_DISK_FLAGS_OPEN;
+	mtx_unlock(&sc->pd_controller->mfi_io_lock);
+
+	return (0);
+}
+
+int
+mfi_syspd_disable(struct mfi_system_pd *sc)
+{
+
+	device_printf(sc->pd_dev,"syspd disable \n");
+	mtx_assert(&sc->pd_controller->mfi_io_lock, MA_OWNED);
+	if (sc->pd_flags & MFI_DISK_FLAGS_OPEN) {
+		if (sc->pd_controller->mfi_delete_busy_volumes)
+			return (0);
+		device_printf(sc->pd_dev, "Unable to delete busy syspd device\n");
+		return (EBUSY);
+	}
+	sc->pd_flags |= MFI_DISK_FLAGS_DISABLED;
+	return (0);
+}
+
+void
+mfi_syspd_enable(struct mfi_system_pd *sc)
+{
+
+	device_printf(sc->pd_dev,"syspd enable \n");
+	mtx_assert(&sc->pd_controller->mfi_io_lock, MA_OWNED);
+	sc->pd_flags &= ~MFI_DISK_FLAGS_DISABLED;
+}
+
+static void
+mfi_syspd_strategy(struct bio *bio)
+{
+	struct mfi_system_pd *sc;
+	struct mfi_softc *controller;
+
+	sc = bio->bio_disk->d_drv1;
+
+	if (sc == NULL) {
+		bio->bio_error = EINVAL;
+		bio->bio_flags |= BIO_ERROR;
+		bio->bio_resid = bio->bio_bcount;
+		biodone(bio);
+		return;
+	}
+
+	controller = sc->pd_controller;
+	bio->bio_driver1 = (void *)(uintptr_t)sc->pd_id;
+	/* Mark it as system PD IO */
+	bio->bio_driver2 = (void *)MFI_SYS_PD_IO;
+	mtx_lock(&controller->mfi_io_lock);
+	mfi_enqueue_bio(controller, bio);
+	mfi_startio(controller);
+	mtx_unlock(&controller->mfi_io_lock);
+	return;
+}
+
+#if 0
+void
+mfi_disk_complete(struct bio *bio)
+{
+	struct mfi_system_pd *sc;
+	struct mfi_frame_header *hdr;
+
+	sc = bio->bio_disk->d_drv1;
+	hdr = bio->bio_driver1;
+
+	if (bio->bio_flags & BIO_ERROR) {
+		if (bio->bio_error == 0)
+			bio->bio_error = EIO;
+		disk_err(bio, "hard error", -1, 1);
+	} else {
+		bio->bio_resid = 0;
+	}
+	biodone(bio);
+}
+#endif
+static int
+mfi_syspd_dump(void *arg, void *virt, vm_offset_t phys, off_t offset, size_t len)
+{
+	
+	struct mfi_system_pd *sc;
+	struct mfi_softc *parent_sc;
+	struct disk *dp;
+	int error;
+
+	dp = arg;
+	sc = dp->d_drv1;
+	parent_sc = sc->pd_controller;
+
+	if (len > 0) {
+		if ((error = mfi_dump_syspd_blocks(parent_sc, sc->pd_id, offset /
+		    MFI_SECTOR_LEN, virt, len)) != 0)
+			return (error);
+	} else {
+		/* mfi_sync_cache(parent_sc, sc->ld_id); */
+	}
+	return (0);
+}
diff -Nur src.orig/sys/dev/mfi/mfireg.h src/sys/dev/mfi/mfireg.h
--- src.orig/sys/dev/mfi/mfireg.h	2012-01-03 11:26:42.000000000 +0800
+++ src/sys/dev/mfi/mfireg.h	2012-03-10 16:47:59.000000000 +0800
@@ -1,60 +1,39 @@
 /*-
- * Copyright (c) 2006 IronPort Systems
- * All rights reserved.
- *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-/*-
- * Copyright (c) 2007 LSI Corp.
- * Copyright (c) 2007 Rajesh Prabhakaran.
- * All rights reserved.
  *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
+ *            Copyright 1994-2009 The FreeBSD Project.
+ *            All rights reserved.   
+ *                 
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
+ *    THIS SOFTWARE IS PROVIDED BY THE FREEBSD PROJECT``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FREEBSD PROJECT OR 
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY,OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY THEORY 
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * The views and conclusions contained in the software and documentation 
+ * are those of the authors and should not be interpreted as representing 
+ * official policies,either expressed or implied, of the FreeBSD Project.	
  */
 
 #ifndef _MFIREG_H
 #define _MFIREG_H
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: release/9.0.0/sys/dev/mfi/mfireg.h 224041 2011-07-14 20:20:33Z jhb $");
+__FBSDID("$FreeBSD: src/sys/dev/mfi/mfireg.h,v 1.10.4.1 2008/02/04 14:54:21 ambrisko Exp $");
 
 /*
  * MegaRAID SAS MFI firmware definitions
@@ -94,10 +73,18 @@
 #define MFI_ODC		0x4 		/* outbound doorbell change interrupt */
 
 /*
- * GEN2 specific changes
+ * gen2 specific changes
+ */ 
+#define MFI_GEN2_EIM	0x00000005	/* gen2 enable interrupt mask */
+#define MFI_GEN2_RM	0x00000001	/* reply gen2 message interrupt */
+
+/*
+ * skinny specific changes
  */
-#define MFI_GEN2_EIM	0x00000005	/* GEN2 enable interrupt mask */
-#define MFI_GEN2_RM	0x00000001	/* reply GEN2 message interrupt */
+#define MFI_SKINNY_IDB	0x00	/* Inbound doorbell is at 0x00 for skinny */
+#define MFI_IQPL	0x000000c0
+#define MFI_IQPH	0x000000c4
+#define MFI_SKINNY_RM	0x00000001	/* reply skinny message interrupt */
 
 /* Bits for MFI_OSTS */
 #define MFI_OSTS_INTR_VALID	0x00000002
@@ -119,7 +106,7 @@
 #define MFI_FWSTATE_FAULT		0xf0000000
 #define MFI_FWSTATE_MAXSGL_MASK		0x00ff0000
 #define MFI_FWSTATE_MAXCMD_MASK		0x0000ffff
-
+#define MFI_FWSTATE_HOSTMEMREQD_MASK	0x08000000
 /*
  * Control bits to drive the card to ready state.  These go into the IDB
  * register.
@@ -145,6 +132,7 @@
 
 /* Direct commands */
 typedef enum {
+	MFI_DCMD_CTRL_MFI_HOST_MEM_ALLOC =	0x0100e100,
 	MFI_DCMD_CTRL_GETINFO =		0x01010000,
 	MFI_DCMD_CTRL_MFC_DEFAULTS_GET =0x010e0201,
 	MFI_DCMD_CTRL_MFC_DEFAULTS_SET =0x010e0202,
@@ -164,6 +152,7 @@
 	MFI_DCMD_FLASH_FW_FLASH =	0x010f0300,
 	MFI_DCMD_FLASH_FW_CLOSE =	0x010f0400,
 	MFI_DCMD_PD_GET_LIST =		0x02010000,
+	MFI_DCMD_PD_LIST_QUERY =	0x02010100,
 	MFI_DCMD_PD_GET_INFO = 		0x02020000,
 	MFI_DCMD_PD_STATE_SET =		0x02030100,
 	MFI_DCMD_PD_REBUILD_START =	0x02040100,
@@ -213,7 +202,7 @@
 #define MFI_FRAME_DIR_WRITE			0x0008
 #define MFI_FRAME_DIR_READ			0x0010
 #define MFI_FRAME_DIR_BOTH			0x0018
-
+#define MFI_FRAME_IEEE_SGL			0x0020
 /* MFI Status codes */
 typedef enum {
 	MFI_STAT_OK =			0x00,
@@ -352,6 +341,15 @@
 	MR_PD_CACHE_DISABLE =		2
 } mfi_pd_cache;
 
+typedef enum {
+	MR_PD_QUERY_TYPE_ALL =		0,
+	MR_PD_QUERY_TYPE_STATE =	1,
+	MR_PD_QUERY_TYPE_POWER_STATE =	2,
+	MR_PD_QUERY_TYPE_MEDIA_TYPE =	3,
+	MR_PD_QUERY_TYPE_SPEED =	4,
+	MR_PD_QUERY_TYPE_EXPOSED_TO_HOST =	5, /*query for system drives */
+}mfi_pd_query_type;
+
 /*
  * Other propertities and definitions
  */
@@ -384,9 +382,16 @@
 	uint32_t	len;
 } __packed;
 
+struct mfi_sg_skinny {
+	uint64_t	addr;
+	uint32_t	len;
+	uint32_t	flag;
+} __packed;
+
 union mfi_sgl {
 	struct mfi_sg32	sg32[1];
 	struct mfi_sg64	sg64[1];
+	struct mfi_sg_skinny sg_skinny[1];
 } __packed;
 
 /* Message frames.  All messages have a common header */
@@ -400,6 +405,10 @@
 	uint8_t		cdb_len;
 	uint8_t		sg_count;
 	uint32_t	context;
+	/*
+	 * pad0 is MSI Specific. Not used by Driver. Zero the value before
+	 * sending the command to f/w
+	 */
 	uint32_t	pad0;
 	uint16_t	flags;
 #define MFI_FRAME_DATAOUT	0x08
@@ -447,10 +456,11 @@
 struct mfi_abort_frame {
 	struct mfi_frame_header header;
 	uint32_t	abort_context;
-	uint32_t	pad;
+	/* pad is changed to reserved.*/
+	uint32_t	reserved0;
 	uint32_t	abort_mfi_addr_lo;
 	uint32_t	abort_mfi_addr_hi;
-	uint32_t	reserved[6];
+	uint32_t	reserved1[6];
 } __packed;
 
 struct mfi_smp_frame {
@@ -909,6 +919,12 @@
 } __packed;
 
 struct mfi_pd_progress {
+/*	struct {
+		uint32_t		rbld	: 1;
+		uint32_t		patrol	: 1;
+		uint32_t		clear	: 1;
+		uint32_t		reserved: 29;
+	} active; */
 	uint32_t			active;
 #define	MFI_PD_PROGRESS_REBUILD	(1<<0)
 #define	MFI_PD_PROGRESS_PATROL	(1<<1)
@@ -931,8 +947,8 @@
 	uint32_t			other_err_count;
 	uint32_t			pred_fail_count;
 	uint32_t			last_pred_fail_event_seq_num;
-	uint16_t			fw_state;	/* MFI_PD_STATE_* */
-	uint8_t				disabled_for_removal;
+	uint16_t			fw_state;
+	uint8_t				disable_for_removal;
 	uint8_t				link_speed;
 	union mfi_pd_ddf_type		state;
 	struct {
@@ -959,15 +975,16 @@
 	uint16_t		encl_device_id;
 	uint8_t			encl_index;
 	uint8_t			slot_number;
-	uint8_t			scsi_dev_type;	/* 0 = disk */
+	uint8_t			scsi_dev_type;
 	uint8_t			connect_port_bitmap;
 	uint64_t		sas_addr[2];
 } __packed;
 
+#define MAX_SYS_PDS 240
 struct mfi_pd_list {
 	uint32_t		size;
 	uint32_t		count;
-	struct mfi_pd_address	addr[0];
+	struct mfi_pd_address	addr[MAX_SYS_PDS];
 } __packed;
 
 enum mfi_pd_state {
@@ -1016,6 +1033,17 @@
 	MFI_LD_STATE_OPTIMAL =			3
 };
 
+/*
+enum mfi_syspd_state {
+	MFI_PD_STATE_UNCONFIGURED_GOOD =	0x00,
+	MFI_PD_STATE_UNCONFIGURED_BAD =		0x01,
+	MFI_PD_STATE_OFFLINE = 			0x10,
+	MFI_PD_STATE_FAILED =			0x11,
+	MFI_PD_STATE_ONLINE =			0x18,
+	MFI_PD_STATE_SYSTEM =			0x40
+};
+*/
+
 struct mfi_ld_props {
 	union mfi_ld_ref	ld;
 	char			name[16];
@@ -1040,7 +1068,9 @@
 #define	MFI_LD_PARAMS_INIT_QUICK	1
 #define	MFI_LD_PARAMS_INIT_FULL		2
 	uint8_t			is_consistent;
-	uint8_t			reserved[23];
+	uint8_t			reserved1[6];
+	uint8_t			isSSCD;
+	uint8_t			reserved2[16];
 } __packed;
 
 struct mfi_ld_progress {
@@ -1081,11 +1111,22 @@
 	uint8_t			reserved2[16];
 } __packed;
 
+union mfi_spare_type {
+	struct {
+		uint8_t		is_dedicate		:1;
+		uint8_t		is_revertable		:1;
+		uint8_t		is_encl_affinity	:1;
+		uint8_t		reserved		:5;
+	} v;
+	uint8_t		type;
+} __packed;
+
 #define MAX_ARRAYS 16
 struct mfi_spare {
 	union mfi_pd_ref	ref;
+//	union mfi_spare_type	spare_type;
 	uint8_t			spare_type;
-#define	MFI_SPARE_DEDICATED	(1 << 0)
+#define	MFI_SPARE_DEDICATED	1
 #define	MFI_SPARE_REVERTIBLE	(1 << 1)
 #define	MFI_SPARE_ENCL_AFFINITY	(1 << 2)
 	uint8_t			reserved[2];
@@ -1093,6 +1134,7 @@
 	uint16_t		array_ref[MAX_ARRAYS];
 } __packed;
 
+//#define MAX_ROW_SIZE 32
 struct mfi_array {
 	uint64_t			size;
 	uint8_t				num_drives;
@@ -1100,8 +1142,8 @@
 	uint16_t			array_ref;
 	uint8_t				pad[20];
 	struct {
-		union mfi_pd_ref	ref;	/* 0xffff == missing drive */
-		uint16_t		fw_state;	/* MFI_PD_STATE_* */
+		union mfi_pd_ref	ref;
+		uint16_t		fw_state;
 		struct {
 			uint8_t		pd;
 			uint8_t		slot;
@@ -1118,9 +1160,10 @@
 	uint16_t		spares_count;
 	uint16_t		spares_size;
 	uint8_t			reserved[16];
-	struct mfi_array	array[0];
-	struct mfi_ld_config	ld[0];
-	struct mfi_spare	spare[0];
+//	uint8_t			data;
+	struct mfi_array	array[1];
+	struct mfi_ld_config	ld[1];
+	struct mfi_spare	spare[1];
 } __packed;
 
 struct mfi_bbu_capacity_info {
diff -Nur src.orig/sys/dev/mfi/mfivar.h src/sys/dev/mfi/mfivar.h
--- src.orig/sys/dev/mfi/mfivar.h	2012-01-03 11:26:42.000000000 +0800
+++ src/sys/dev/mfi/mfivar.h	2010-02-18 14:51:16.000000000 +0800
@@ -1,60 +1,39 @@
 /*-
- * Copyright (c) 2006 IronPort Systems
- * All rights reserved.
- *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
  *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-/*-
- * Copyright (c) 2007 LSI Corp.
- * Copyright (c) 2007 Rajesh Prabhakaran.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
+ *            Copyright 1994-2009 The FreeBSD Project.
+ *            All rights reserved.   
+ *                 
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
+ *    THIS SOFTWARE IS PROVIDED BY THE FREEBSD PROJECT``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FREEBSD PROJECT OR 
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY,OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY THEORY 
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * The views and conclusions contained in the software and documentation 
+ * are those of the authors and should not be interpreted as representing 
+ * official policies,either expressed or implied, of the FreeBSD Project.	
  */
 
 #ifndef _MFIVAR_H
 #define _MFIVAR_H
 
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: release/9.0.0/sys/dev/mfi/mfivar.h 227117 2011-11-05 18:27:47Z kib $");
+__FBSDID("$FreeBSD: src/sys/dev/mfi/mfivar.h,v 1.11 2007/08/25 23:58:45 scottl Exp $");
 
 #include <sys/lock.h>
 #include <sys/sx.h>
@@ -87,7 +66,6 @@
 	union mfi_sgl		*cm_sg;
 	void			*cm_data;
 	int			cm_len;
-	int			cm_stp_len;
 	int			cm_total_frame_size;
 	int			cm_extra_frames;
 	int			cm_flags;
@@ -120,11 +98,28 @@
 #define	MFI_DISK_FLAGS_DISABLED	0x02
 };
 
+struct mfi_system_pd {
+	TAILQ_ENTRY(mfi_system_pd)	pd_link;
+	device_t	pd_dev;
+	int		pd_id;
+	int		pd_unit;
+	struct mfi_softc *pd_controller;
+	struct mfi_pd_info	*pd_info;
+	struct disk	*pd_disk;
+	int		pd_flags;
+};
 struct mfi_aen {
 	TAILQ_ENTRY(mfi_aen) aen_link;
 	struct proc			*p;
 };
 
+struct mfi_skinny_dma_info {
+	bus_dma_tag_t	dmat[514];
+	bus_dmamap_t	dmamap[514];
+	uint32_t	mem[514];
+	int		noofmaps;
+};
+
 struct mfi_softc {
 	device_t			mfi_dev;
 	int				mfi_flags;
@@ -135,6 +130,7 @@
 #define MFI_FLAGS_1064R		(1<<4)
 #define MFI_FLAGS_1078		(1<<5)
 #define MFI_FLAGS_GEN2		(1<<6)
+#define MFI_FLAGS_SKINNY	(1<<7)
 
 	struct mfi_hwcomms		*mfi_comms;
 	TAILQ_HEAD(,mfi_command)	mfi_free;
@@ -162,6 +158,7 @@
 
 	TAILQ_HEAD(,mfi_aen)		mfi_aen_pids;
 	struct mfi_command		*mfi_aen_cm;
+	struct mfi_command		*mfi_skinny_cm;
 	uint32_t			mfi_aen_triggered;
 	uint32_t			mfi_poll_waiting;
 	struct selinfo			mfi_select;
@@ -215,6 +212,7 @@
 	uint32_t			mfi_max_io;
 
 	TAILQ_HEAD(,mfi_disk)		mfi_ld_tqh;
+	TAILQ_HEAD(,mfi_system_pd)	mfi_syspd_tqh;
 	eventhandler_tag		mfi_eh;
 	struct cdev			*mfi_cdev;
 
@@ -239,6 +237,9 @@
 extern int mfi_disk_disable(struct mfi_disk *);
 extern void mfi_disk_enable(struct mfi_disk *);
 extern int mfi_dump_blocks(struct mfi_softc *, int id, uint64_t, void *, int);
+extern int mfi_syspd_disable(struct mfi_system_pd *);
+extern void mfi_syspd_enable(struct mfi_system_pd *);
+extern int mfi_dump_syspd_blocks(struct mfi_softc *, int id, uint64_t, void *, int);
 
 #define MFIQ_ADD(sc, qname)					\
 	do {							\
@@ -352,29 +353,12 @@
 	return (bp);
 }
 
-/*
- * This is from the original scsi_extract_sense() in CAM.  It's copied
- * here because CAM now uses a non-inline version that follows more complex
- * additions to the SPC spec, and we don't want to force a dependency on
- * the CAM module for such a trivial action.
- */
-static __inline void
-mfi_extract_sense(struct scsi_sense_data_fixed *sense,
-    int *error_code, int *sense_key, int *asc, int *ascq)
-{
-
-	*error_code = sense->error_code & SSD_ERRCODE;
-	*sense_key = sense->flags & SSD_KEY;
-	*asc = (sense->extra_len >= 5) ? sense->add_sense_code : 0;
-	*ascq = (sense->extra_len >= 6) ? sense->add_sense_code_qual : 0;
-}
-
 static __inline void
 mfi_print_sense(struct mfi_softc *sc, void *sense)
 {
 	int error, key, asc, ascq;
 
-	mfi_extract_sense((struct scsi_sense_data_fixed *)sense,
+	scsi_extract_sense((struct scsi_sense_data *)sense,
 	    &error, &key, &asc, &ascq);
 	device_printf(sc->mfi_dev, "sense error %d, sense_key %d, "
 	    "asc %d, ascq %d\n", error, key, asc, ascq);
@@ -397,8 +381,9 @@
 MALLOC_DECLARE(M_MFIBUF);
 
 #define MFI_CMD_TIMEOUT 30
-#define MFI_MAXPHYS (128 * 1024)
-
+#define MFI_SYS_PD_IO	0
+#define MFI_LD_IO	1
+#define SKINNY_MEMORY 0x02000000
 #ifdef MFI_DEBUG
 extern void mfi_print_cmd(struct mfi_command *cm);
 extern void mfi_dump_cmds(struct mfi_softc *sc);
